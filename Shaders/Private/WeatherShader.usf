//Reference LICENSE_2 for the simulation code contained in here!
#pragma once
//#include "/Engine/Private/Common.ush"
#include "WeatherConstantProperties.ush"
#include "WeatherVariableProperties.ush"

//Tricks so i don't have to re-write the c++ struct accessor functions
#define gridRslow(col, i, j, k) gridRslow[GetAirIndex(col, i, j, k)].CellColumns.col

#define gridInit(col, i, j, k) gridInit[GetAirIndex(col, i, j, k)].CellColumns.col
#define currGC(col, i, j, k) grid3D[GetGridIndex(currGC)+GetAirIndex(col, i, j, k)].CellColumns.col
#define prevGC(col, i, j, k) grid3D[GetGridIndex(prevGC)+GetAirIndex(col, i, j, k)].CellColumns.col
#define nextGC(col, i, j, k) grid3D[GetGridIndex(nextGC)+GetAirIndex(col, i, j, k)].CellColumns.col
#define ground(col, i, j) ground[GetGroundIndex(col, i, j)].CellColumns.col

//More tricks to keep original code
#define FLT_MAX 3.402823466e+38F
#define powf pow
#define logf log
#define fmin min
#define sqrtf sqrt
//first rename gridSizeK[k] with gridSizeK(k)
#define gridSizeK(k) gridSizeK[k].Cell

int GetGridIndex(int arr)
{
    return gridX * gridY * gridZ * arr;
}


int GetAirIndex(int arr, int x, int y, int z)
{

    float result;



    int aI = x; // Toroidal behavior: (x<0)-->(x=gridX-1-x) and (x>gridX-1)-->(x=x-gridX-1)
    if (aI < 0)
        {
            aI = gridX + x;
        }

    if (aI >= gridX)
        {
            aI = (x % gridX);
        }

    int aJ = y; // Toroidal
    if (aJ < 0)
        {
            aJ = gridY + y;
        }

    if (aJ >= gridY)
        {
            aJ = (y % gridY);
        }

    int aZ = z;
    int gridK = gridZ;

    if (arr == W)
        {
            gridK++;
        }
       

    aZ = max(0, aZ); //not under
    aZ = min(aZ, gridK - 2); //not over top


    if ((z < 0 || z >= gridK) && (arr <= 2 || arr == 8))
        { //for values (under z<0, or higher than the gridK) AND they are arr<=2 (u,v,w) or arr==8 (rL)
            result = 0.0f;
        }
        else
        {
        result = aI + aJ * gridX + aZ * (gridX * gridY);
        }
    return result;
}

	/* Operators to acces the data in a toroidal manner */
int GetGroundIndex(int arr, int x, int y)
{


    int aY = y; // toroidal behavior
    if (y < 0)
        {
        aY = gridY + y;
        }
    if (y >= gridY)
    {
        aY = (y % gridY);
    }

    int aX = x; // toroidal behavior
    if (x < 0)
    {
        aX = gridX + x;
    }
    if (x >= gridX)
    {
        aX = (x % gridX);
    }
    return aX + aY * gridY;
}

 
///////////////////////////////////////
// SIMULATION STEPS

/* STEP 1 Fundamental Equations */
void simulateSTEP1()
{

    [loop]
    for (int k = 0; k < gridZ - 1; k++)
    {
        int km1 = k - 1;
        if (km1 < 0)
        {
            km1 = 0;
        }
        [loop]
        for (int j = 0; j < gridY; j++)
        {
            [loop]
            for (int i = 0; i < gridX; i++)
            {
                gridRslow(U, i, j, k) =
                -1.0f / gridSizeI * (powf(0.5f * (currGC(U, i + 1, j, k) + currGC(U, i, j, k)), 2) - powf(0.5f * (currGC(U, i, j, k) + currGC(U, i - 1, j, k)), 2)) // -duu/dx

                - 1.0f / gridSizeJ * (
                0.5f * (currGC(U, i, j + 1, k) + currGC(U, i, j, k)) * 0.5f * (currGC(V, i, j + 1, k) + currGC(V, i - 1, j + 1, k))
                - 0.5f * (currGC(U, i, j, k) + currGC(U, i, j - 1, k)) * 0.5f * (currGC(V, i, j, k) + currGC(V, i - 1, j, k))) // -duv/dy

                - 1.0f / (currGC(RO, i, j, k) * gridSizeK(k)) * (
                0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * 0.5f * (currGC(W, i, j, k + 1) + currGC(W, i - 1, j, k + 1)) * 0.5f * (currGC(U, i, j, k + 1) + currGC(U, i, j, k))
                - 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * 0.5f * (currGC(W, i, j, k) + currGC(W, i - 1, j, k)) * 0.5f * (currGC(U, i, j, k - 1) + currGC(U, i, j, k))) // -dpuw/dz
                - 1.0f / gridSizeI * (cpd * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k)) * (currGC(Pi, i, j, k) - currGC(Pi, i - 1, j, k))) // -cpd*T*dP/dx
                + Kx / powf(gridSizeI, 2) * (prevGC(U, i + 1, j, k) - 2.0f * prevGC(U, i, j, k) + prevGC(U, i - 1, j, k))
                + Ky / powf(gridSizeJ, 2) * (prevGC(U, i, j + 1, k) - 2.0f * prevGC(U, i, j, k) + prevGC(U, i, j - 1, k))
                + Kz / powf(gridSizeK(k), 2) * ((prevGC(U, i, j, k + 1) - gridInit(U, i, j, k + 1)) - 2.0f * (prevGC(U, i, j, k) - gridInit(U, i, j, k)) + (prevGC(U, i, j, k - 1) - gridInit(U, i, j, k - 1))); // Diffusion (implicit)


                gridRslow(V, i, j, k) =
                -1.0f / gridSizeI * (
                0.5f * (currGC(V, i + 1, j, k) + currGC(V, i, j, k)) * 0.5f * (currGC(U, i + 1, j, k) + currGC(U, i + 1, j - 1, k))
                - 0.5f * (currGC(V, i, j, k) + currGC(V, i - 1, j, k)) * 0.5f * (currGC(U, i, j - 1, k) + currGC(U, i, j, k))) // -dvu/dx 

                - 1.0f / gridSizeJ * (powf(0.5f * (currGC(V, i, j + 1, k) + currGC(V, i, j, k)), 2) - powf(0.5f * (currGC(V, i, j, k) + currGC(V, i, j - 1, k)), 2)) // -dvv/dy

                - 1.0f / (currGC(RO, i, j, k) * gridSizeK(k)) * (
                0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * 0.5f * (currGC(W, i, j, k + 1) + currGC(W, i, j - 1, k + 1)) * 0.5f * (currGC(V, i, j, k + 1) + currGC(V, i, j, k))
                - 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * 0.5f * (currGC(W, i, j, k) + currGC(W, i, j - 1, k)) * 0.5f * (currGC(V, i, j, k - 1) + currGC(V, i, j, k))) // -dpvw/dz
                - 1.0f / gridSizeJ * (cpd * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k)) * (currGC(Pi, i, j, k) - currGC(Pi, i, j - 1, k))) // -cpd*T*dP/dx
                + Kx / powf(gridSizeI, 2) * (prevGC(V, i + 1, j, k) - 2.0f * prevGC(V, i, j, k) + prevGC(V, i - 1, j, k))
                + Ky / powf(gridSizeJ, 2) * (prevGC(V, i, j + 1, k) - 2.0f * prevGC(V, i, j, k) + prevGC(V, i, j - 1, k))
                + Kz / powf(gridSizeK(k), 2) * ((prevGC(V, i, j, k + 1) - gridInit(V, i, j, k + 1)) - 2.0f * (prevGC(V, i, j, k) - gridInit(V, i, j, k)) + (prevGC(V, i, j, k - 1) - gridInit(V, i, j, k - 1))); // Diffusion (implicit)

                //MAXED OUT INSTRUCTIONS
                //gridRslow(W, i, j, k) =
                //-1.0f / gridSizeI * (
                //0.5f * (currGC(U, i + 1, j, k) + currGC(U, i + 1, j, k - 1)) * 0.5f * (currGC(W, i + 1, j, k) + currGC(W, i, j, k))
                //- 0.5f * (currGC(U, i, j, k) + currGC(U, i, j, k - 1)) * 0.5f * (currGC(W, i, j, k) + currGC(W, i - 1, j, k))) // -duw/dx

                //- 1.0f / gridSizeJ * (
                //0.5f * (currGC(V, i, j + 1, k) + currGC(V, i, j + 1, k - 1)) * 0.5f * (currGC(W, i, j + 1, k) + currGC(W, i, j, k))
                //- 0.5f * (currGC(V, i, j, k) + currGC(V, i, j, k - 1)) * 0.5f * (currGC(W, i, j, k) + currGC(W, i, j - 1, k))) // -duw/dx

                //- 1.0f / (0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * 0.5f * (gridSizeK(k) + gridSizeK(km1))) *
                //(currGC(RO, i, j, k) * powf(0.5f * (currGC(W, i, j, k + 1) + currGC(W, i, j, k)), 2) - currGC(RO, i, j, k - 1) * powf(0.5f * (currGC(W, i, j, k) + currGC(W, i, j, k - 1)), 2)) // -dpww/dz
                //- 1.0f / (0.5f * (gridSizeK(k) + gridSizeK(km1))) *
                //(cpd * 0.5f * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k) + gridInit(THETA, i, j, k - 1) + 0.61f * gridInit(QV, i, j, k - 1))
                //* (currGC(Pi, i, j, k) - currGC(Pi, i, j, k - 1))) // -cpd* T*dP/dz
                //+ g * 0.5f * (currGC(THETA, i, j, k) / gridInit(THETA, i, j, k) + currGC(THETA, i, j, k - 1) / gridInit(THETA, i, j, k - 1)
                //+ 0.61f * (currGC(QV, i, j, k) + currGC(QV, i, j, k - 1)) - (currGC(QC, i, j, k) + currGC(QC, i, j, k - 1) + currGC(QR, i, j, k) + currGC(QR, i, j, k - 1))) // B=g* T'/T
                //+ Kx / powf(gridSizeI, 2) * (prevGC(W, i + 1, j, k) - 2.0f * prevGC(W, i, j, k) + prevGC(W, i - 1, j, k)) // Diffusion (implicit)
                //+ Ky / powf(gridSizeJ, 2) * (prevGC(W, i, j + 1, k) - 2.0f * prevGC(W, i, j, k) + prevGC(W, i, j - 1, k)) // Diffusion (implicit)
                //+ Kz / powf(gridSizeK(k), 2) * (prevGC(W, i, j, k + 1) - 2.0f * prevGC(W, i, j, k) + prevGC(W, i, j, k - 1)); // d2w/dx2+d2w/dz2

                //MAXED OUT INSTRUCTIONS
                //gridRslow(THETA, i, j, k) =
                //-1.0f / gridSizeI * (currGC(U, i + 1, j, k) * 0.5f * (currGC(THETA, i + 1, j, k) + currGC(THETA, i, j, k))
                //- currGC(U, i, j, k) * 0.5f * (currGC(THETA, i, j, k) + currGC(THETA, i - 1, j, k))) // -duT/dx

                //- 1.0f / gridSizeJ * (currGC(V, i, j + 1, k) * 0.5f * (currGC(THETA, i, j + 1, k) + currGC(THETA, i, j, k))
                //- currGC(V, i, j, k) * 0.5f * (currGC(THETA, i, j, k) + currGC(THETA, i, j - 1, k))) // -dvT/dx NN

                //- 1.0f / (currGC(RO, i, j, k) * gridSizeK(k)) * (
                //0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * 0.5f * (currGC(THETA, i, j, k + 1) + currGC(THETA, i, j, k))
                //- 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * 0.5f * (currGC(THETA, i, j, k) + currGC(THETA, i, j, k - 1))) // -dpwT/dz
                //- 1.0f / (currGC(RO, i, j, k)) * 0.5f * (
                //0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * (gridInit(THETA, i, j, k + 1) - gridInit(THETA, i, j, k)) / gridSizeK(k + 1)
                //+ 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * (gridInit(THETA, i, j, k) - gridInit(THETA, i, j, k - 1)) / gridSizeK(k)) // -w/p*dpT/dz (mean state)
                //+ Kx / powf(gridSizeI, 2) * (prevGC(THETA, i + 1, j, k) - 2.0f * prevGC(THETA, i, j, k) + prevGC(THETA, i - 1, j, k)) // Diffusion (implicit)
                //+ Ky / powf(gridSizeJ, 2) * (prevGC(THETA, i, j + 1, k) - 2.0f * prevGC(THETA, i, j, k) + prevGC(THETA, i, j - 1, k)) // Diffusion (implicit)
                //+ Kz / powf(gridSizeK(k), 2) * (prevGC(THETA, i, j, k + 1) - 2.0f * prevGC(THETA, i, j, k) + prevGC(THETA, i, j, k - 1)); // d2T/dx2+d2T/dz2

                gridRslow(Pi, i, j, k) =
                -1.0f * (powf(cmax, 2) / (currGC(RO, i, j, k) * cpd * powf(gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k), 2))) * ( // multiplier -cs^2/(cpd* p*T^2)
                +(currGC(RO, i, j, k) * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k)) * (currGC(U, i + 1, j, k) - currGC(U, i, j, k))) / gridSizeI // pTdu/dx

                + (currGC(RO, i, j, k) * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k)) * (currGC(V, i, j + 1, k) - currGC(V, i, j, k))) / gridSizeJ // pTdv/dx

                + (0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * 0.5f * (gridInit(THETA, i, j, k + 1) + gridInit(THETA, i, j, k))
                - 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * 0.5f * (gridInit(THETA, i, j, k) + gridInit(THETA, i, j, k - 1))) / gridSizeK(k) // pTdw/dz
                )
                + Kx / powf(gridSizeI, 2) * (prevGC(Pi, i + 1, j, k) - 2.0f * prevGC(Pi, i, j, k) + prevGC(Pi, i - 1, j, k)) // Diffusion (implicit)
                + Ky / powf(gridSizeI, 2) * (prevGC(Pi, i, j + 1, k) - 2.0f * prevGC(Pi, i, j, k) + prevGC(Pi, i, j - 1, k)) // Diffusion (implicit)
                + Kz / powf(gridSizeK(k), 2) * (prevGC(Pi, i, j, k + 1) - 2.0f * prevGC(Pi, i, j, k) + prevGC(Pi, i, j, k - 1)); // d2P/dx2+d2P/dz2

                //MAXED OUT INSTRUCTIONS
                //// Moisture terms
                //gridRslow(QV, i, j, k) =
                //-1.0f / gridSizeI * (currGC(U, i + 1, j, k) * 0.5f * (currGC(QV, i + 1, j, k) + currGC(QV, i, j, k))
                //- currGC(U, i, j, k) * 0.5f * (currGC(QV, i, j, k) + currGC(QV, i - 1, j, k))) // -duqv/dx

                //- 1.0f / gridSizeJ * (currGC(V, i, j + 1, k) * 0.5f * (currGC(QV, i, j + 1, k) + currGC(QV, i, j, k))
                //- currGC(V, i, j, k) * 0.5f * (currGC(QV, i, j, k) + currGC(QV, i, j - 1, k))) // -dvqv/dy

                //- 1.0f / (currGC(RO, i, j, k) * gridSizeK(k)) * (
                //0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * 0.5f * (currGC(QV, i, j, k + 1) + currGC(QV, i, j, k))
                //- 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * 0.5f * (currGC(QV, i, j, k) + currGC(QV, i, j, k - 1))) // -dpwqv/dz
                //- 1.0f / (currGC(RO, i, j, k)) * 0.5f * (
                //0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * (gridInit(QV, i, j, k + 1) - gridInit(QV, i, j, k)) / gridSizeK(k + 1)
                //+ 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * (gridInit(QV, i, j, k) - gridInit(QV, i, j, k - 1)) / gridSizeK(k)) // -w/p*dpqv/dz (mean state)
                //+ Kx / powf(gridSizeI, 2) * (prevGC(QV, i + 1, j, k) - 2.0f * prevGC(QV, i, j, k) + prevGC(QV, i - 1, j, k)) // Diffusion (implicit)
                //+ Ky / powf(gridSizeI, 2) * (prevGC(QV, i, j + 1, k) - 2.0f * prevGC(QV, i, j, k) + prevGC(QV, i, j - 1, k)) // Diffusion (implicit)
                //+ Kz / powf(gridSizeK(k), 2) * (prevGC(QV, i, j, k + 1) - 2.0f * prevGC(QV, i, j, k) + prevGC(QV, i, j, k - 1)); // d2q/dx2+d2q/dz2

                
                gridRslow(QC, i, j, k) =
                -1.0f / gridSizeI * (currGC(U, i + 1, j, k) * 0.5f * (currGC(QC, i + 1, j, k) + currGC(QC, i, j, k))
                - currGC(U, i, j, k) * 0.5f * (currGC(QC, i, j, k) + currGC(QC, i - 1, j, k))) // -duqv/dx

                - 1.0f / gridSizeJ * (currGC(V, i, j + 1, k) * 0.5f * (currGC(QC, i, j + 1, k) + currGC(QC, i, j, k))
                - currGC(V, i, j, k) * 0.5f * (currGC(QC, i, j, k) + currGC(QC, i, j - 1, k))) // -duqv/dx

                - 1.0f / (currGC(RO, i, j, k) * gridSizeK(k)) * (
                0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * 0.5f * (currGC(QC, i, j, k + 1) + currGC(QC, i, j, k))
                - 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * 0.5f * (currGC(QC, i, j, k) + currGC(QC, i, j, k - 1))) // -dpwqv/dz
                + Kx / powf(gridSizeI, 2) * (prevGC(QC, i + 1, j, k) - 2.0f * prevGC(QC, i, j, k) + prevGC(QC, i - 1, j, k)) // Diffusion (implicit)
                + Ky / powf(gridSizeI, 2) * (prevGC(QC, i, j + 1, k) - 2.0f * prevGC(QC, i, j, k) + prevGC(QC, i, j - 1, k)) // Diffusion (implicit)
                + Kz / powf(gridSizeK(k), 2) * (prevGC(QC, i, j, k + 1) - 2.0f * prevGC(QC, i, j, k) + prevGC(QC, i, j, k - 1)); // d2q/dx2+d2q/dz2

                //MAXED OUT INSTRUCTIONS
                //gridRslow(QR, i, j, k) =
                //-1.0f / gridSizeI * (currGC(U, i + 1, j, k) * 0.5f * (currGC(QR, i + 1, j, k) + currGC(QR, i, j, k))
                //- currGC(U, i, j, k) * 0.5f * (currGC(QR, i, j, k) + currGC(QR, i - 1, j, k))) // -duqv/dx

                //- 1.0f / gridSizeJ * (currGC(V, i, j + 1, k) * 0.5f * (currGC(QR, i, j + 1, k) + currGC(QR, i, j, k))
                //- currGC(V, i, j, k) * 0.5f * (currGC(QR, i, j, k) + currGC(QR, i, j - 1, k))) // -dvqv/dy

                //- 1.0f / (currGC(RO, i, j, k) * gridSizeK(k)) * (
                //0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * 0.5f * (currGC(QR, i, j, k + 1) + currGC(QR, i, j, k))
                //- 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * 0.5f * (currGC(QR, i, j, k) + currGC(QR, i, j, k - 1))) // -dpwqv/dz
                //+ Kx / powf(gridSizeI, 2) * (prevGC(QR, i + 1, j, k) - 2.0f * prevGC(QR, i, j, k) + prevGC(QR, i - 1, j, k)) // Diffusion (implicit)
                //+ Ky / powf(gridSizeI, 2) * (prevGC(QR, i, j + 1, k) - 2.0f * prevGC(QR, i, j, k) + prevGC(QR, i, j - 1, k)) // Diffusion (implicit)
                //+ Kz / powf(gridSizeK(k), 2) * (prevGC(QR, i, j, k + 1) - 2.0f * prevGC(QR, i, j, k) + prevGC(QR, i, j, k - 1)); // d2q/dx2+d2q/dz2

                //gridRslow(RO, i, j, k) = 0.0f;
                gridRslow(RO, i, j, k) = 1.2f / gridSizeI / gridSizeJ;
            }
        }
    }
}

/* STEP 1 Fundamental Equations */
void simulateSTEP1a()
{

    [loop]
    for (int k = 0; k < gridZ - 1; k++)
    {
        int km1 = k - 1;
        if (km1 < 0)
        {
            km1 = 0;
        }
        [loop]
        for (int j = 0; j < gridY; j++)
        {
            [loop]
            for (int i = 0; i < gridX; i++)
            {
                //gridRslow(W, i, j, k) =
                //-1.0f / gridSizeI * (
                //0.5f * (currGC(U, i + 1, j, k) + currGC(U, i + 1, j, k - 1)) * 0.5f * (currGC(W, i + 1, j, k) + currGC(W, i, j, k))
                //- 0.5f * (currGC(U, i, j, k) + currGC(U, i, j, k - 1)) * 0.5f * (currGC(W, i, j, k) + currGC(W, i - 1, j, k))) // -duw/dx

                //- 1.0f / gridSizeJ * (
                //0.5f * (currGC(V, i, j + 1, k) + currGC(V, i, j + 1, k - 1)) * 0.5f * (currGC(W, i, j + 1, k) + currGC(W, i, j, k))
                //- 0.5f * (currGC(V, i, j, k) + currGC(V, i, j, k - 1)) * 0.5f * (currGC(W, i, j, k) + currGC(W, i, j - 1, k))) // -duw/dx

                //- 1.0f / (0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * 0.5f * (gridSizeK(k) + gridSizeK(km1))) *
                //(currGC(RO, i, j, k) * powf(0.5f * (currGC(W, i, j, k + 1) + currGC(W, i, j, k)), 2) - currGC(RO, i, j, k - 1) * powf(0.5f * (currGC(W, i, j, k) + currGC(W, i, j, k - 1)), 2)) // -dpww/dz
                //- 1.0f / (0.5f * (gridSizeK(k) + gridSizeK(km1))) *
                //(cpd * 0.5f * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k) + gridInit(THETA, i, j, k - 1) + 0.61f * gridInit(QV, i, j, k - 1))
                //* (currGC(Pi, i, j, k) - currGC(Pi, i, j, k - 1))) // -cpd* T*dP/dz
                //+ g * 0.5f * (currGC(THETA, i, j, k) / gridInit(THETA, i, j, k) + currGC(THETA, i, j, k - 1) / gridInit(THETA, i, j, k - 1)
                //+ 0.61f * (currGC(QV, i, j, k) + currGC(QV, i, j, k - 1)) - (currGC(QC, i, j, k) + currGC(QC, i, j, k - 1) + currGC(QR, i, j, k) + currGC(QR, i, j, k - 1))) // B=g* T'/T
                //+ Kx / powf(gridSizeI, 2) * (prevGC(W, i + 1, j, k) - 2.0f * prevGC(W, i, j, k) + prevGC(W, i - 1, j, k)) // Diffusion (implicit)
                //+ Ky / powf(gridSizeJ, 2) * (prevGC(W, i, j + 1, k) - 2.0f * prevGC(W, i, j, k) + prevGC(W, i, j - 1, k)) // Diffusion (implicit)
                //+ Kz / powf(gridSizeK(k), 2) * (prevGC(W, i, j, k + 1) - 2.0f * prevGC(W, i, j, k) + prevGC(W, i, j, k - 1)); // d2w/dx2+d2w/dz2





                 gridRslow(QR, i, j, k) =
                -1.0f / gridSizeI * (currGC(U, i + 1, j, k) * 0.5f * (currGC(QR, i + 1, j, k) + currGC(QR, i, j, k))
                - currGC(U, i, j, k) * 0.5f * (currGC(QR, i, j, k) + currGC(QR, i - 1, j, k))) // -duqv/dx

                - 1.0f / gridSizeJ * (currGC(V, i, j + 1, k) * 0.5f * (currGC(QR, i, j + 1, k) + currGC(QR, i, j, k))
                - currGC(V, i, j, k) * 0.5f * (currGC(QR, i, j, k) + currGC(QR, i, j - 1, k))) // -dvqv/dy

                - 1.0f / (currGC(RO, i, j, k) * gridSizeK(k)) * (
                0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * 0.5f * (currGC(QR, i, j, k + 1) + currGC(QR, i, j, k))
                - 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * 0.5f * (currGC(QR, i, j, k) + currGC(QR, i, j, k - 1))) // -dpwqv/dz
                + Kx / powf(gridSizeI, 2) * (prevGC(QR, i + 1, j, k) - 2.0f * prevGC(QR, i, j, k) + prevGC(QR, i - 1, j, k)) // Diffusion (implicit)
                + Ky / powf(gridSizeI, 2) * (prevGC(QR, i, j + 1, k) - 2.0f * prevGC(QR, i, j, k) + prevGC(QR, i, j - 1, k)) // Diffusion (implicit)
                + Kz / powf(gridSizeK(k), 2) * (prevGC(QR, i, j, k + 1) - 2.0f * prevGC(QR, i, j, k) + prevGC(QR, i, j, k - 1)); // d2q/dx2+d2q/dz2

            }
        }
    }
}


/* STEP 1 Fundamental Equations */
void simulateSTEP1b()
{

    [loop]
    for (int k = 0; k < gridZ - 1; k++)
    {
        int km1 = k - 1;
        if (km1 < 0)
        {
            km1 = 0;
        }
        [loop]
        for (int j = 0; j < gridY; j++)
        {
            [loop]
            for (int i = 0; i < gridX; i++)
            {
                // gridRslow(THETA, i, j, k) =
                //-1.0f / gridSizeI * (currGC(U, i + 1, j, k) * 0.5f * (currGC(THETA, i + 1, j, k) + currGC(THETA, i, j, k))
                //- currGC(U, i, j, k) * 0.5f * (currGC(THETA, i, j, k) + currGC(THETA, i - 1, j, k))) // -duT/dx

                //- 1.0f / gridSizeJ * (currGC(V, i, j + 1, k) * 0.5f * (currGC(THETA, i, j + 1, k) + currGC(THETA, i, j, k))
                //- currGC(V, i, j, k) * 0.5f * (currGC(THETA, i, j, k) + currGC(THETA, i, j - 1, k))) // -dvT/dx NN

                //- 1.0f / (currGC(RO, i, j, k) * gridSizeK(k)) * (
                //0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * 0.5f * (currGC(THETA, i, j, k + 1) + currGC(THETA, i, j, k))
                //- 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * 0.5f * (currGC(THETA, i, j, k) + currGC(THETA, i, j, k - 1))) // -dpwT/dz
                //- 1.0f / (currGC(RO, i, j, k)) * 0.5f * (
                //0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * (gridInit(THETA, i, j, k + 1) - gridInit(THETA, i, j, k)) / gridSizeK(k + 1)
                //+ 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * (gridInit(THETA, i, j, k) - gridInit(THETA, i, j, k - 1)) / gridSizeK(k)) // -w/p*dpT/dz (mean state)
                //+ Kx / powf(gridSizeI, 2) * (prevGC(THETA, i + 1, j, k) - 2.0f * prevGC(THETA, i, j, k) + prevGC(THETA, i - 1, j, k)) // Diffusion (implicit)
                //+ Ky / powf(gridSizeJ, 2) * (prevGC(THETA, i, j + 1, k) - 2.0f * prevGC(THETA, i, j, k) + prevGC(THETA, i, j - 1, k)) // Diffusion (implicit)
                //+ Kz / powf(gridSizeK(k), 2) * (prevGC(THETA, i, j, k + 1) - 2.0f * prevGC(THETA, i, j, k) + prevGC(THETA, i, j, k - 1)); // d2T/dx2+d2T/dz2


                //MAXED OUT INSTRUCTIONS
                // Moisture terms
                //gridRslow(QV, i, j, k) =
                //-1.0f / gridSizeI * (currGC(U, i + 1, j, k) * 0.5f * (currGC(QV, i + 1, j, k) + currGC(QV, i, j, k))
                //- currGC(U, i, j, k) * 0.5f * (currGC(QV, i, j, k) + currGC(QV, i - 1, j, k))) // -duqv/dx

                //- 1.0f / gridSizeJ * (currGC(V, i, j + 1, k) * 0.5f * (currGC(QV, i, j + 1, k) + currGC(QV, i, j, k))
                //- currGC(V, i, j, k) * 0.5f * (currGC(QV, i, j, k) + currGC(QV, i, j - 1, k))) // -dvqv/dy

                //- 1.0f / (currGC(RO, i, j, k) * gridSizeK(k)) * (
                //0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * 0.5f * (currGC(QV, i, j, k + 1) + currGC(QV, i, j, k))
                //- 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * 0.5f * (currGC(QV, i, j, k) + currGC(QV, i, j, k - 1))) // -dpwqv/dz
                //- 1.0f / (currGC(RO, i, j, k)) * 0.5f * (
                //0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * currGC(W, i, j, k + 1) * (gridInit(QV, i, j, k + 1) - gridInit(QV, i, j, k)) / gridSizeK(k + 1)
                //+ 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * currGC(W, i, j, k) * (gridInit(QV, i, j, k) - gridInit(QV, i, j, k - 1)) / gridSizeK(k)) // -w/p*dpqv/dz (mean state)
                //+ Kx / powf(gridSizeI, 2) * (prevGC(QV, i + 1, j, k) - 2.0f * prevGC(QV, i, j, k) + prevGC(QV, i - 1, j, k)) // Diffusion (implicit)
                //+ Ky / powf(gridSizeI, 2) * (prevGC(QV, i, j + 1, k) - 2.0f * prevGC(QV, i, j, k) + prevGC(QV, i, j - 1, k)) // Diffusion (implicit)
                //+ Kz / powf(gridSizeK(k), 2) * (prevGC(QV, i, j, k + 1) - 2.0f * prevGC(QV, i, j, k) + prevGC(QV, i, j, k - 1)); // d2q/dx2+d2q/dz2
            }
        }
    }
}

/* STEP2: Kelsner Microphysics */
void simulateSTEP2()
{

    [loop]
    for (int k = 1; k < gridZ - 1; k++)
    {
        [loop]
        for (int j = 0; j < gridY; j++)
        {
            [loop]
            for (int i = 0; i < gridX; i++)
            {

        // Kessler microphysics.
        // A = max[ k1 * (qc-qc0) , 0 ] : autoconverstion qc -> qr
        // B = k2 * qc * qr^7/8	: accretion qc -> qr
        // C: condensation ; qv <-> qv
        // E: evaporation ; qr -> qv
        // All values from t-1 step
        // Order of calculation matters here

                float A_conv = 0.0;
                if (prevGC(QC, i, j, k) > 0.001)
                    A_conv = max(0.0f, 0.001 * (prevGC(QC, i, j, k) - 0.001)); // conversion cloud -> rain

                float B_acc = max(0.0f, gridInit(RO, i, j, k) * 2.2f * prevGC(QC, i, j, k) * powf(prevGC(QR, i, j, k), 0.875f)); // accretion cloud -> rain

                A_conv *= rainProbability;
                B_acc *= rainProbability;

        // Saturation adjustment (Soong & Ogura)
                float pmean = powf(gridInit(Pi, i, j, k), cpd / Rd) * p_0; // Mean pressure
                float qvs = (380.0f / pmean) * exp(7.5f * log(10.0f) *
          ((prevGC(THETA, i, j, k) + gridInit(THETA, i, j, k)) * ((prevGC(Pi, i, j, k) + gridInit(Pi, i, j, k))) - 273.0f) /
          ((prevGC(THETA, i, j, k) + gridInit(THETA, i, j, k)) * ((prevGC(Pi, i, j, k) + gridInit(Pi, i, j, k))) - 36.0f)); // Saturation mixing ratio
                prevGC(QV, i, j, k) = max(prevGC(QV, i, j, k), -1.0f * gridInit(QV, i, j, k)); // remove negative values
                float rsub = qvs * (7.5f * logf(10.0f) * (273.0f - 36.0f) * Llv / cpd) /
          powf(gridInit(Pi, i, j, k) * (prevGC(THETA, i, j, k) + gridInit(THETA, i, j, k)), 2);

                float Cond = min(prevGC(QV, i, j, k) + gridInit(QV, i, j, k),
          max(0.0f, ((prevGC(QV, i, j, k) + gridInit(QV, i, j, k)) - qvs) / (1.0f + rsub))); // Condensation (qv -> qc)

                float Cvent = 1.6f + 124.9f * powf(gridInit(RO, i, j, k) * prevGC(QC, i, j, k), 0.2046f); // ventillation factor
                float Evap = min(min(prevGC(QR, i, j, k), max(-1.0f * Cond - prevGC(QC, i, j, k), 0.0f)), // 3 options
                dT * Cvent * powf(gridInit(RO, i, j, k) * prevGC(QR, i, j, k), 0.525f) / (5.4e5 + 2.55e8 / (pmean * qvs))
          * max(qvs - prevGC(QV, i, j, k), 0.0f) / (gridInit(RO, i, j, k) * qvs));
                Cond = max(Cond, -1.0f * prevGC(QC, i, j, k));

                gridRslow(QV, i, j, k) = gridRslow(QV, i, j, k) - Cond + Evap; // Net mass conversion

                gridRslow(QC, i, j, k) = gridRslow(QC, i, j, k) + Cond - A_conv - B_acc; // Net mass conversion

                float vterm0 = 36.34f * sqrtf(gridInit(RO, i, j, 0) / gridInit(RO, i, j, k)) * powf(max(gridInit(RO, i, j, k) * prevGC(QR, i, j, k), 0.0f), 0.1364f);
                float vterm1 = 36.34f * sqrtf(gridInit(RO, i, j, 0) / gridInit(RO, i, j, k + 1)) * powf(max(gridInit(RO, i, j, k + 1) * prevGC(QR, i, j, k + 1), 0.0f), 0.1364f); // vT terminal velocity
        // note, it's possible that vT > CFL.

                gridRslow(QR, i, j, k) = gridRslow(QR, i, j, k) + A_conv + B_acc - Evap // Net mass change
          + 1.0f / (currGC(RO, i, j, k) * gridSizeK(k)) * (
          0.5f * (currGC(RO, i, j, k + 1) + currGC(RO, i, j, k)) * vterm1 * 0.5f * (prevGC(QR, i, j, k + 1) + prevGC(QR, i, j, k))
          - 0.5f * (currGC(RO, i, j, k) + currGC(RO, i, j, k - 1)) * vterm0 * 0.5f * (prevGC(QR, i, j, k) + prevGC(QR, i, j, k - 1))); // Falling rain

                gridRslow(THETA, i, j, k) = gridRslow(THETA, i, j, k) + Llv / (cpd * gridInit(Pi, i, j, k)) * (Cond - Evap); // latent heating Lv/(cpd * P) * (C-E);
            }
        }
    }
}

/* STEP3: Move forward in time */
void simulateSTEP3()
{

    [loop]
    for (int k = 1; k < gridZ - 1; k++)
    {
        [loop]
        for (int j = 0; j < gridY; j++)
        {
            [loop]
            for (int i = 0; i < gridX; i++)
            {

                if (simulationTime == 0.0f)
                { // 1st step: forward in time
          //	printf("first Iteration\n");
                    nextGC(U, i, j, k) = currGC(U, i, j, k) + dT * gridRslow(U, i, j, k);
                    nextGC(V, i, j, k) = currGC(V, i, j, k) + dT * gridRslow(V, i, j, k);
                    nextGC(W, i, j, k) = currGC(W, i, j, k) + dT * gridRslow(W, i, j, k);
                    if ((k < 2))
                        nextGC(W, i, j, k) = 0.0f; // top & bottom BCs //|| (k==zEnd)
                    nextGC(Pi, i, j, k) = currGC(Pi, i, j, k) + dT * gridRslow(Pi, i, j, k);
                    nextGC(THETA, i, j, k) = currGC(THETA, i, j, k) + dT * gridRslow(THETA, i, j, k);
                    nextGC(QV, i, j, k) = currGC(QV, i, j, k) + dT * gridRslow(QV, i, j, k);
                    nextGC(QC, i, j, k) = currGC(QC, i, j, k) + dT * gridRslow(QC, i, j, k);
                    nextGC(QR, i, j, k) = currGC(QR, i, j, k) + dT * gridRslow(QR, i, j, k);
                    nextGC(RO, i, j, k) = currGC(RO, i, j, k) + dT * gridRslow(RO, i, j, k);

                }
                else
                { // subsequent steps: leapfrog

          //	printf("No first Iteration\n");
                    nextGC(U, i, j, k) = prevGC(U, i, j, k) + 2.0f * dT * gridRslow(U, i, j, k);
                    nextGC(V, i, j, k) = prevGC(V, i, j, k) + 2.0f * dT * gridRslow(V, i, j, k);
                    nextGC(W, i, j, k) = prevGC(W, i, j, k) + 2.0f * dT * gridRslow(W, i, j, k);
                    if ((k < 2))
                        nextGC(W, i, j, k) = 0.0f; // top & bottom BCs // || (k==zEnd)
                    nextGC(Pi, i, j, k) = prevGC(Pi, i, j, k) + 2.0f * dT * gridRslow(Pi, i, j, k);
                    nextGC(THETA, i, j, k) = prevGC(THETA, i, j, k) + 2.0f * dT * gridRslow(THETA, i, j, k);
                    nextGC(QV, i, j, k) = prevGC(QV, i, j, k) + 2.0f * dT * gridRslow(QV, i, j, k);
                    nextGC(QC, i, j, k) = prevGC(QC, i, j, k) + 2.0f * dT * gridRslow(QC, i, j, k);
                    nextGC(QR, i, j, k) = prevGC(QR, i, j, k) + 2.0f * dT * gridRslow(QR, i, j, k);
                    nextGC(RO, i, j, k) = prevGC(RO, i, j, k) + 2.0f * dT * gridRslow(RO, i, j, k);

          // Roberts-Asselin filter
                    currGC(U, i, j, k) = currGC(U, i, j, k) + 0.1f * (nextGC(U, i, j, k) - 2.0f * currGC(U, i, j, k) + prevGC(U, i, j, k));
                    currGC(V, i, j, k) = currGC(V, i, j, k) + 0.1f * (nextGC(V, i, j, k) - 2.0f * currGC(V, i, j, k) + prevGC(V, i, j, k));
                    currGC(W, i, j, k) = currGC(W, i, j, k) + 0.1f * (nextGC(W, i, j, k) - 2.0f * currGC(W, i, j, k) + prevGC(W, i, j, k));
                    currGC(THETA, i, j, k) = currGC(THETA, i, j, k) + 0.1f * (nextGC(THETA, i, j, k) - 2.0f * currGC(THETA, i, j, k) + prevGC(THETA, i, j, k));
                    currGC(Pi, i, j, k) = currGC(Pi, i, j, k) + 0.1f * (nextGC(Pi, i, j, k) - 2.0f * currGC(Pi, i, j, k) + prevGC(Pi, i, j, k));
                    currGC(QV, i, j, k) = currGC(QV, i, j, k) + 0.1f * (nextGC(QV, i, j, k) - 2.0f * currGC(QV, i, j, k) + prevGC(QV, i, j, k));
                    currGC(QC, i, j, k) = currGC(QC, i, j, k) + 0.1f * (nextGC(QC, i, j, k) - 2.0f * currGC(QC, i, j, k) + prevGC(QC, i, j, k));
                    currGC(QR, i, j, k) = currGC(QR, i, j, k) + 0.1f * (nextGC(QR, i, j, k) - 2.0f * currGC(QR, i, j, k) + prevGC(QR, i, j, k));
                    currGC(RO, i, j, k) = currGC(RO, i, j, k) + 0.1f * (nextGC(RO, i, j, k) - 2.0f * currGC(RO, i, j, k) + prevGC(RO, i, j, k));
                }
            }
        }
    }
} // STEP 3

/* STEP4: Radiation model */
void simulateSTEP4()
{

    [loop]
    for (int j = 0; j < gridY; j++)
    {
        [loop]
        for (int i = 0; i < gridX; i++)
        {



      ////////////////////////////////////////
      // INIT VALUES
            if (simulationTime == 0.0f)
            { // 1st step: forward in time 
                currGC(THETA, i, j, 0) = 0;

                ground(GR_TG, i, j) = 23.5f + 273.15f;
                ground(GR_TA, i, j) = gridInit(THETA, i, j, 0);

                ground(GR_TG_RESET, i, j) = FLT_MAX; // INF

                ground(GR_TG_CORR, i, j) = 0.0f;
                ground(GR_TA_CORR, i, j) = 0.0f;

                ground(GR_CLOUD_COVER, i, j) = 0.0f;
            }

      ////////////////////////////////////////
      // CLOUD COVERAGE

            if ((int(simulationTime / dT) % (60 * 5)) == 0)
            { // each 300 steps
                float cloudTotal = 0.0f;
                [loop]
                for (int z = (0.33f * gridZ);
                z < (0.83f * gridZ);
                z++)
                {
                    float density = nextGC(QC, i, j, z);
                    if (density == 0.0f)
                        continue;
                    if (density > 2e-3f)
                    {
                        density = 0.99f;
                    }
                    else
                    {
                        if (density < 1e-3f)
                        {
                            density = 0.0f;
                        }
                        else
                        {
                            density = -1520000.0f * (density * density) + 5360.00f * (density) - 3.74f;
                        }
                    }
                    cloudTotal += density * 0.1f; //0.05f so it has soft borders
                    if (cloudTotal >= 1.0f)
                    {
                        break; // not necessary to check more
                    }
                }
                ground(GR_CLOUD_COVER, i, j) = fmin(cloudTotal, 1.0f);
            }


      // UTC
            float t_UTC = initTimeUTC_hours + (simulationTime / 3600.0f); //day overflow
            int advancedDays = int(t_UTC / (24.0f)); //full days
            float dayInYearUTC = initDayInYearUTC + advancedDays;

            while (dayInYearUTC > 365)
                dayInYearUTC -= 365;
            t_UTC -= advancedDays * 24.0f;

    //  // LOCAL
            float t_Local = t_UTC + timeZone;

            if (t_Local < 0.0f)
            {
                t_Local += 24.0f;
            }

            if (t_Local > 24.0f)
            {
                t_Local -= 24.0f;
            }


            float lat = latitudeRad;
            float longi = -longitudeRad; //note NEGATE (West)

            float delta = 0.409f * cos((2.0f * M_PI) * (dayInYearUTC - 173.0f) / (365.25f)); //d_s: solarDeclineAngle
            float sinPSI = sin(lat) * sin(delta) - cos(lat) * cos(delta) * cos(((M_PI * t_UTC) / 12.0f) - longi);

            float gamma = 0.0000010717f * powf(t_Local, 5.0f) + 0.0000818369f * powf(t_Local, 4.0f) - 0.0060500842f * powf(t_Local, 3.0f) + 0.0772306397f * powf(t_Local, 2.0f) + 0.1444444444f * t_Local - 1.8441558442f;


    //  // RADITATION

            float alb = ground(GR_ALBEDO, i, j);
            float c_g_a = ground(GR_CGA, i, j);

            float sig_l = ground(GR_CLOUD_COVER, i, j);
            float sig_m = ground(GR_CLOUD_COVER, i, j);


            float I = 0.08f * (1.0f - 0.1f * sig_h - 0.3f * sig_m - 0.6f * sig_l);

            float Tk = (0.6f + 0.2f * sinPSI) * (1.0f - 0.4f * sig_h) * (1.0f - 0.7f * sig_m) * (1.0f - 0.4f * sig_l); //trans
            float Q_net = (1.0f - alb) * S_const * Tk * sinPSI + I;
            if (sinPSI < 0)
                Q_net = I;
            float a_fr;
            if (ground(GR_TG, i, j) > ground(GR_TA, i, j))
            {
        //DAY
                a_fr = 3e-4f;
            }
            else
            {
        //NIGHT
                a_fr = 1.1e-4f;
            }

            float T_G_t = ((-Q_net / c_g_a) + (2.0f * M_PI / dur * (T_M - ground(GR_TG, i, j))) - (a_fr * (ground(GR_TG, i, j) - ground(GR_TA, i, j))));
            float Q_g = -1.0f * ((c_g_a * T_G_t) + (2.0f * M_PI * c_g_a / dur * (ground(GR_TG, i, j) - T_M))); //Units are fomd
            float Q_h = (-Q_net + Q_g) / ground(GR_BETA_INV, i, j);

            ground(GR_TG, i, j) += (dT * T_G_t) + ground(GR_TG_CORR, i, j); // NEW TG
            ground(GR_TA, i, j) += (dT * Q_h * 1.0e-3f) + ground(GR_TA_CORR, i, j); // Introduced this new time parameterization //NEW TA

      // STEP 0: Save ref value after 2 hours of simulation
            if ((ground(GR_TG_RESET, i, j) == FLT_MAX) && (simulationTime >= 3600.0f * 2.0f))
            { // put first FLT_MAX to avoid to comparisons
                ground(GR_TG_RESET, i, j) = ground(GR_TG, i, j);
                ground(GR_TA_RESET, i, j) = ground(GR_TA, i, j);
            }

      // STEP1: Update Correction after Each 24hours (+2h)
            if ((simulationTime >= 3600.0f * (2.0f + 24.0f)) && ((int(simulationTime) - 2 * 3600)) % (24 * 3600) == 0)
            { // RESET
                float TG_diff = ground(GR_TG_RESET, i, j) - ground(GR_TG, i, j);
                float TA_diff = ground(GR_TA_RESET, i, j) - ground(GR_TA, i, j);
                ground(GR_TG_CORR, i, j) = (TG_diff / (24.0f * 3600.0f)) * dT * 1.2f; //1.2f correction factor
                ground(GR_TA_CORR, i, j) = (TA_diff / (24.0f * 3600.0f)) * dT * 1.2f;
            }

            nextGC(THETA, i, j, 0) = ground(GR_TA, i, j) + gamma * gridSizeK(0) / 100.0f - gridInit(THETA, i, j, 0); //transfer of Ta to THETA
        }
    }
} //STEP 4 



///////////////////////////////////////////////////////////////////////////
// RUN SIMULATION
[numthreads(1, 1, 1)]
void simulateStep(int3 DTid : SV_DispatchThreadID)
{
    // Fundamental equations.
    simulateSTEP1();
    simulateSTEP1a();
   // simulateSTEP1b();

    // Microphysics.
    simulateSTEP2();

    // Move in time.
    simulateSTEP3();

    // Radiation.
    simulateSTEP4();

    simulationTime += dT;
}