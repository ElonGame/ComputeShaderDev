//Reference LICENSE_2 for the simulation code contained in here!
#pragma once
//#include "/Engine/Private/Common.ush"
#include "WeatherConstantProperties.ush"
#include "WeatherVariableProperties.ush"
#include "/Engine/Public/Platform.ush" //<-Ignore the errors this works fine
#include "/Engine/Private/Common.ush" //<-Ignore the errors this works fine
//#include "/Engine/Private/ShaderPrintCommon.ush" //<-Ignore the errors this works fine


//tricks to keep original code
#define FLT_MAX 3.402823466e+38F
#define powf pow
#define logf log
#define fmin min
#define sqrtf sqrt


///////////////////////////////////////////////////////////////////////////

int torid_ground(int x, int y)
{
    int aY = y; // toroidal behavior
    if (y < 0)
        aY = gridY + y;
    if (y >= gridY)
        aY = (y % gridY);

    int aX = x; // toroidal behavior
    if (x < 0)
        aX = gridX + x;
    if (x >= gridX)
        aX = (x % gridX);

    return (aX + aY * gridY); //return that value
}


int torid(int arr, int x, int y, int z)
{
    int aI = x; // Toroidal behavior: (x<0)-->(x=gridX-1-x) and (x>gridX-1)-->(x=x-gridX-1)
    if (aI < 0)
        aI = gridX + x;
    if (aI >= gridX)
        aI = (x % gridX);
    int aJ = y; // Toroidal
    if (aJ < 0)
        aJ = gridY + y;
    if (aJ >= gridY)
        aJ = (y % gridY);
    int aZ = z;
    int gridK = gridZ;
    if (arr == W)
        gridK++;
    if ((z < 0 || z >= gridK) && (arr <= 2 || arr == 8))
    { //for values (under z<0, or higher than the gridK) AND they are arr<=2 (u,v,w) or arr==8 (rL)
        return 0;
    }
    aZ = max(0, aZ); //not under
    aZ = min(aZ, gridK - 2); //not over top
    return aI + aJ * gridX + aZ * (gridX * gridY);
}

///////////////////////////////////////////////////////////////////////////

/* STEP 1 Fundamental Equations */
float simulateSTEP1()
{
    float u_test = 0;
    float v_test = 0;
    float w_test = 0;
    float theta_test = 0;
    float pi_test = 0;
    float qv_test = 0;
    float qc_test = 0;
    float qr_test = 0;
    float Step1TestTotal = 0;

    for (int k = 1; k < gridZ - 1; k++)
    {
        for (int j = 0; j < gridY; j++)
        {
            for (int i = 0; i < gridX; i++)
            {

                int km1 = k - 1;
                if (km1 < 0)
                    km1 = 0;

				//These are already defined
				//const float Kx = 500.0f; // diffusion coefficients
				//const float Kz = 100.0f;

				//float gridSizeK_TEST = gridSizeK[k];

				//int test = torid(RO, i, j, k - 1);
				//printf("////////////////////////////\nStep1 torrid: %d\n", test);

                u_test =
				gridRslow[torid(U, i, j, k)].U =
					-1.0f / gridSizeI * (powf(0.5f * (Grid3D_curr[(torid(U, i + 1, j, k))].U + Grid3D_curr[torid(U, i, j, k)].U), 2) - powf(0.5f * (Grid3D_curr[torid(U, i, j, k)].U + Grid3D_curr[torid(U, i - 1, j, k)].U), 2)) // -duu/dx

					- 1.0f / gridSizeJ * (
						0.5f * (Grid3D_curr[torid(U, i, j + 1, k)].U + Grid3D_curr[torid(U, i, j, k)].U) * 0.5f * (Grid3D_curr[torid(V, i, j + 1, k)].V + Grid3D_curr[torid(V, i - 1, j + 1, k)].V)
						- 0.5f * (Grid3D_curr[torid(U, i, j, k)].U + Grid3D_curr[torid(U, i, j - 1, k)].U) * 0.5f * (Grid3D_curr[torid(V, i, j, k)].V + Grid3D_curr[torid(V, i - 1, j, k)].V)) // -duv/dy

					- 1.0f / (Grid3D_curr[torid(RO, i, j, k)].RO * gridSizeK[k]) * (
						0.5f * (Grid3D_curr[torid(RO, i, j, k + 1)].RO + Grid3D_curr[torid(RO, i, j, k)].RO) * 0.5f * (Grid3D_curr[torid(W, i, j, k + 1)].W + Grid3D_curr[torid(W, i - 1, j, k + 1)].W) * 0.5f * (Grid3D_curr[torid(U, i, j, k + 1)].U + Grid3D_curr[torid(U, i, j, k)].U)
						- 0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * 0.5f * (Grid3D_curr[torid(W, i, j, k)].W + Grid3D_curr[torid(W, i - 1, j, k)].W) * 0.5f * (Grid3D_curr[torid(U, i, j, k - 1)].U + Grid3D_curr[torid(U, i, j, k)].U)) // -dpuw/dz
					- 1.0f / gridSizeI * (cpd * (gridInit[torid(THETA, i, j, k)].THETA + 0.61f * gridInit[torid(QV, i, j, k)].QV) * (Grid3D_curr[torid(Pi, i, j, k)].Pi - Grid3D_curr[torid(Pi, i - 1, j, k)].Pi)) // -cpd*T*dP/dx
					+ Kx / powf(gridSizeI, 2) * (Grid3D_prev[torid(U, i + 1, j, k)].U - 2.0f * Grid3D_prev[torid(U, i, j, k)].U + Grid3D_prev[torid(U, i - 1, j, k)].U)
					+ Ky / powf(gridSizeJ, 2) * (Grid3D_prev[torid(U, i, j + 1, k)].U - 2.0f * Grid3D_prev[torid(U, i, j, k)].U + Grid3D_prev[torid(U, i, j - 1, k)].U)
					+ Kz / powf(gridSizeK[k], 2) * ((Grid3D_prev[torid(U, i, j, k + 1)].U - gridInit[torid(U, i, j, k + 1)].U) - 2.0f * (Grid3D_prev[torid(U, i, j, k)].U - gridInit[torid(U, i, j, k)].U) + (Grid3D_prev[torid(U, i, j, k - 1)].U - gridInit[torid(U, i, j, k - 1)].U)); // Diffusion (implicit)


                v_test =
				gridRslow[torid(V, i, j, k)].V =
					-1.0f / gridSizeI * (
						0.5f * (Grid3D_curr[torid(V, i + 1, j, k)].V + Grid3D_curr[torid(V, i, j, k)].V) * 0.5f * (Grid3D_curr[torid(U, i + 1, j, k)].U + Grid3D_curr[torid(U, i + 1, j - 1, k)].U)
						- 0.5f * (Grid3D_curr[torid(V, i, j, k)].V + Grid3D_curr[torid(V, i - 1, j, k)].V) * 0.5f * (Grid3D_curr[torid(U, i, j - 1, k)].U + Grid3D_curr[torid(U, i, j, k)].U)) // -dvu/dx 

					- 1.0f / gridSizeJ * (powf(0.5f * (Grid3D_curr[torid(V, i, j + 1, k)].V + Grid3D_curr[torid(V, i, j, k)].V), 2) - powf(0.5f * (Grid3D_curr[torid(V, i, j, k)].V + Grid3D_curr[torid(V, i, j - 1, k)].V), 2)) // -dvv/dy

					- 1.0f / (Grid3D_curr[torid(RO, i, j, k)].RO * gridSizeK[k]) * (
						0.5f * (Grid3D_curr[torid(RO, i, j, k + 1)].RO + Grid3D_curr[torid(RO, i, j, k)].RO) * 0.5f * (Grid3D_curr[torid(W, i, j, k + 1)].W + Grid3D_curr[torid(W, i, j - 1, k + 1)].W) * 0.5f * (Grid3D_curr[torid(V, i, j, k + 1)].V + Grid3D_curr[torid(V, i, j, k)].V)
						- 0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * 0.5f * (Grid3D_curr[torid(W, i, j, k)].W + Grid3D_curr[torid(W, i, j - 1, k)].W) * 0.5f * (Grid3D_curr[torid(V, i, j, k - 1)].V + Grid3D_curr[torid(V, i, j, k)].V)) // -dpvw/dz
					- 1.0f / gridSizeJ * (cpd * (gridInit[torid(THETA, i, j, k)].THETA + 0.61f * gridInit[torid(QV, i, j, k)].QV) * (Grid3D_curr[torid(Pi, i, j, k)].Pi - Grid3D_curr[torid(Pi, i, j - 1, k)].Pi)) // -cpd*T*dP/dx
					+ Kx / powf(gridSizeI, 2) * (Grid3D_prev[torid(V, i + 1, j, k)].V - 2.0f * Grid3D_prev[torid(V, i, j, k)].V + Grid3D_prev[torid(V, i - 1, j, k)].V)
					+ Ky / powf(gridSizeJ, 2) * (Grid3D_prev[torid(V, i, j + 1, k)].V - 2.0f * Grid3D_prev[torid(V, i, j, k)].V + Grid3D_prev[torid(V, i, j - 1, k)].V)
					+ Kz / powf(gridSizeK[k], 2) * ((Grid3D_prev[torid(V, i, j, k + 1)].V - gridInit[torid(V, i, j, k + 1)].V) - 2.0f * (Grid3D_prev[torid(V, i, j, k)].V - gridInit[torid(V, i, j, k)].V) + (Grid3D_prev[torid(V, i, j, k - 1)].V - gridInit[torid(V, i, j, k - 1)].V)); // Diffusion (implicit)

                w_test =
				gridRslow[torid(W, i, j, k)].W =
					-1.0f / gridSizeI * (
						0.5f * (Grid3D_curr[torid(U, i + 1, j, k)].U + Grid3D_curr[torid(U, i + 1, j, k - 1)].U) * 0.5f * (Grid3D_curr[torid(W, i + 1, j, k)].W + Grid3D_curr[torid(W, i, j, k)].W)
						- 0.5f * (Grid3D_curr[torid(U, i, j, k)].U + Grid3D_curr[torid(U, i, j, k - 1)].U) * 0.5f * (Grid3D_curr[torid(W, i, j, k)].W + Grid3D_curr[torid(W, i - 1, j, k)].W)) // -duw/dx

					- 1.0f / gridSizeJ * (
						0.5f * (Grid3D_curr[torid(V, i, j + 1, k)].V + Grid3D_curr[torid(V, i, j + 1, k - 1)].V) * 0.5f * (Grid3D_curr[torid(W, i, j + 1, k)].W + Grid3D_curr[torid(W, i, j, k)].W)
						- 0.5f * (Grid3D_curr[torid(V, i, j, k)].V + Grid3D_curr[torid(V, i, j, k - 1)].V) * 0.5f * (Grid3D_curr[torid(W, i, j, k)].W + Grid3D_curr[torid(W, i, j - 1, k)].W)) // -duw/dx

					- 1.0f / (0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * 0.5f * (gridSizeK[k] + gridSizeK[km1])) *
					(Grid3D_curr[torid(RO, i, j, k)].RO * powf(0.5f * (Grid3D_curr[torid(W, i, j, k + 1)].W + Grid3D_curr[torid(W, i, j, k)].W), 2) - Grid3D_curr[torid(RO, i, j, k - 1)].RO * powf(0.5f * (Grid3D_curr[torid(W, i, j, k)].W + Grid3D_curr[torid(W, i, j, k - 1)].W), 2)) // -dpww/dz
					- 1.0f / (0.5f * (gridSizeK[k] + gridSizeK[km1])) *
					(cpd * 0.5f * (gridInit[torid(THETA, i, j, k)].THETA + 0.61f * gridInit[torid(QV, i, j, k)].QV + gridInit[torid(THETA, i, j, k - 1)].THETA + 0.61f * gridInit[torid(QV, i, j, k - 1)].QV)
						* (Grid3D_curr[torid(Pi, i, j, k)].Pi - Grid3D_curr[torid(Pi, i, j, k - 1)].Pi)) // -cpd* T*dP/dz
					+ g * 0.5f * (Grid3D_curr[torid(THETA, i, j, k)].THETA / gridInit[torid(THETA, i, j, k)].THETA + Grid3D_curr[torid(THETA, i, j, k - 1)].THETA / gridInit[torid(THETA, i, j, k - 1)].THETA
						+ 0.61f * (Grid3D_curr[torid(QV, i, j, k)].QV + Grid3D_curr[torid(QV, i, j, k - 1)].QV) - (Grid3D_curr[torid(QC, i, j, k)].QC + Grid3D_curr[torid(QC, i, j, k - 1)].QC + Grid3D_curr[torid(QR, i, j, k)].QR + Grid3D_curr[torid(QR, i, j, k - 1)].QR)) // B=g* T'/T
					+ Kx / powf(gridSizeI, 2) * (Grid3D_prev[torid(W, i + 1, j, k)].W - 2.0f * Grid3D_prev[torid(W, i, j, k)].W + Grid3D_prev[torid(W, i - 1, j, k)].W) // Diffusion (implicit)
					+ Ky / powf(gridSizeJ, 2) * (Grid3D_prev[torid(W, i, j + 1, k)].W - 2.0f * Grid3D_prev[torid(W, i, j, k)].W + Grid3D_prev[torid(W, i, j - 1, k)].W) // Diffusion (implicit)
					+ Kz / powf(gridSizeK[k], 2) * (Grid3D_prev[torid(W, i, j, k + 1)].W - 2.0f * Grid3D_prev[torid(W, i, j, k)].W + Grid3D_prev[torid(W, i, j, k - 1)].W); // d2w/dx2+d2w/dz2

                theta_test =
				gridRslow[torid(THETA, i, j, k)].THETA =
					-1.0f / gridSizeI * (Grid3D_curr[torid(U, i + 1, j, k)].U * 0.5f * (Grid3D_curr[torid(THETA, i + 1, j, k)].THETA + Grid3D_curr[torid(THETA, i, j, k)].THETA)
						- Grid3D_curr[torid(U, i, j, k)].U * 0.5f * (Grid3D_curr[torid(THETA, i, j, k)].THETA + Grid3D_curr[torid(THETA, i - 1, j, k)].THETA)) // -duT/dx

					- 1.0f / gridSizeJ * (Grid3D_curr[torid(V, i, j + 1, k)].V * 0.5f * (Grid3D_curr[torid(THETA, i, j + 1, k)].THETA + Grid3D_curr[torid(THETA, i, j, k)].THETA)
						- Grid3D_curr[torid(V, i, j, k)].V * 0.5f * (Grid3D_curr[torid(THETA, i, j, k)].THETA + Grid3D_curr[torid(THETA, i, j - 1, k)].THETA)) // -dvT/dx NN

					- 1.0f / (Grid3D_curr[torid(RO, i, j, k)].RO * gridSizeK[k]) * (
						0.5f * (Grid3D_curr[torid(RO, i, j, k + 1)].RO + Grid3D_curr[torid(RO, i, j, k)].RO) * Grid3D_curr[torid(W, i, j, k + 1)].W * 0.5f * (Grid3D_curr[torid(THETA, i, j, k + 1)].THETA + Grid3D_curr[torid(THETA, i, j, k)].THETA)
						- 0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * Grid3D_curr[torid(W, i, j, k)].W * 0.5f * (Grid3D_curr[torid(THETA, i, j, k)].THETA + Grid3D_curr[torid(THETA, i, j, k - 1)].THETA)) // -dpwT/dz
					- 1.0f / (Grid3D_curr[torid(RO, i, j, k)].RO) * 0.5f * (
						0.5f * (Grid3D_curr[torid(RO, i, j, k + 1)].RO + Grid3D_curr[torid(RO, i, j, k)].RO) * Grid3D_curr[torid(W, i, j, k + 1)].W * (gridInit[torid(THETA, i, j, k + 1)].THETA - gridInit[torid(THETA, i, j, k)].THETA) / gridSizeK[k + 1]
						+ 0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * Grid3D_curr[torid(W, i, j, k)].W * (gridInit[torid(THETA, i, j, k)].THETA - gridInit[torid(THETA, i, j, k - 1)].THETA) / gridSizeK[k]) // -w/p*dpT/dz (mean state)
					+ Kx / powf(gridSizeI, 2) * (Grid3D_prev[torid(THETA, i + 1, j, k)].THETA - 2.0f * Grid3D_prev[torid(THETA, i, j, k)].THETA + Grid3D_prev[torid(THETA, i - 1, j, k)].THETA) // Diffusion (implicit)
					+ Ky / powf(gridSizeJ, 2) * (Grid3D_prev[torid(THETA, i, j + 1, k)].THETA - 2.0f * Grid3D_prev[torid(THETA, i, j, k)].THETA + Grid3D_prev[torid(THETA, i, j - 1, k)].THETA) // Diffusion (implicit)
					+ Kz / powf(gridSizeK[k], 2) * (Grid3D_prev[torid(THETA, i, j, k + 1)].THETA - 2.0f * Grid3D_prev[torid(THETA, i, j, k)].THETA + Grid3D_prev[torid(THETA, i, j, k - 1)].THETA); // d2T/dx2+d2T/dz2

                pi_test =
				gridRslow[torid(Pi, i, j, k)].Pi =
					-1.0f * (powf(cmax, 2) / (Grid3D_curr[torid(RO, i, j, k)].RO * cpd * powf(gridInit[torid(THETA, i, j, k)].THETA + 0.61f * gridInit[torid(QV, i, j, k)].QV, 2))) * ( // multiplier -cs^2/(cpd* p*T^2)
						+(Grid3D_curr[torid(RO, i, j, k)].RO * (gridInit[torid(THETA, i, j, k)].THETA + 0.61f * gridInit[torid(QV, i, j, k)].QV) * (Grid3D_curr[torid(U, i + 1, j, k)].U - Grid3D_curr[torid(U, i, j, k)].U)) / gridSizeI // pTdu/dx

						+ (Grid3D_curr[torid(RO, i, j, k)].RO * (gridInit[torid(THETA, i, j, k)].THETA + 0.61f * gridInit[torid(QV, i, j, k)].QV) * (Grid3D_curr[torid(V, i, j + 1, k)].V - Grid3D_curr[torid(V, i, j, k)].V)) / gridSizeJ // pTdv/dx

						+ (0.5f * (Grid3D_curr[torid(RO, i, j, k + 1)].RO + Grid3D_curr[torid(RO, i, j, k)].RO) * Grid3D_curr[torid(W, i, j, k + 1)].W * 0.5f * (gridInit[torid(THETA, i, j, k + 1)].THETA + gridInit[torid(THETA, i, j, k)].THETA)
							- 0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * Grid3D_curr[torid(W, i, j, k)].W * 0.5f * (gridInit[torid(THETA, i, j, k)].THETA + gridInit[torid(THETA, i, j, k - 1)].THETA)) / gridSizeK[k] // pTdw/dz
						)
					+ Kx / powf(gridSizeI, 2) * (Grid3D_prev[torid(Pi, i + 1, j, k)].Pi - 2.0f * Grid3D_prev[torid(Pi, i, j, k)].Pi + Grid3D_prev[torid(Pi, i - 1, j, k)].Pi) // Diffusion (implicit)
					+ Ky / powf(gridSizeI, 2) * (Grid3D_prev[torid(Pi, i, j + 1, k)].Pi - 2.0f * Grid3D_prev[torid(Pi, i, j, k)].Pi + Grid3D_prev[torid(Pi, i, j - 1, k)].Pi) // Diffusion (implicit)
					+ Kz / powf(gridSizeK[k], 2) * (Grid3D_prev[torid(Pi, i, j, k + 1)].Pi - 2.0f * Grid3D_prev[torid(Pi, i, j, k)].Pi + Grid3D_prev[torid(Pi, i, j, k - 1)].Pi); // d2P/dx2+d2P/dz2

				  // Moisture terms

                qv_test =
				gridRslow[torid(QV, i, j, k)].QV =
					-1.0f / gridSizeI * (Grid3D_curr[torid(U, i + 1, j, k)].U * 0.5f * (Grid3D_curr[torid(QV, i + 1, j, k)].QV + Grid3D_curr[torid(QV, i, j, k)].QV)
						- Grid3D_curr[torid(U, i, j, k)].U * 0.5f * (Grid3D_curr[torid(QV, i, j, k)].QV + Grid3D_curr[torid(QV, i - 1, j, k)].QV)) // -duqv/dx

					- 1.0f / gridSizeJ * (Grid3D_curr[torid(V, i, j + 1, k)].V * 0.5f * (Grid3D_curr[torid(QV, i, j + 1, k)].QV + Grid3D_curr[torid(QV, i, j, k)].QV)
						- Grid3D_curr[torid(V, i, j, k)].V * 0.5f * (Grid3D_curr[torid(QV, i, j, k)].QV + Grid3D_curr[torid(QV, i, j - 1, k)].QV)) // -dvqv/dy

					- 1.0f / (Grid3D_curr[torid(RO, i, j, k)].RO * gridSizeK[k]) * (
						0.5f * (Grid3D_curr[torid(RO, i, j, k + 1)].RO + Grid3D_curr[torid(RO, i, j, k)].RO) * Grid3D_curr[torid(W, i, j, k + 1)].W * 0.5f * (Grid3D_curr[torid(QV, i, j, k + 1)].QV + Grid3D_curr[torid(QV, i, j, k)].QV)
						- 0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * Grid3D_curr[torid(W, i, j, k)].W * 0.5f * (Grid3D_curr[torid(QV, i, j, k)].QV + Grid3D_curr[torid(QV, i, j, k - 1)].QV)) // -dpwqv/dz
					- 1.0f / (Grid3D_curr[torid(RO, i, j, k)].RO) * 0.5f * (
						0.5f * (Grid3D_curr[torid(RO, i, j, k + 1)].RO + Grid3D_curr[torid(RO, i, j, k)].RO) * Grid3D_curr[torid(W, i, j, k + 1)].W * (gridInit[torid(QV, i, j, k + 1)].QV - gridInit[torid(QV, i, j, k)].QV) / gridSizeK[k + 1]
						+ 0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * Grid3D_curr[torid(W, i, j, k)].W * (gridInit[torid(QV, i, j, k)].QV - gridInit[torid(QV, i, j, k - 1)].QV) / gridSizeK[k]) // -w/p*dpqv/dz (mean state)
					+ Kx / powf(gridSizeI, 2) * (Grid3D_prev[torid(QV, i + 1, j, k)].QV - 2.0f * Grid3D_prev[torid(QV, i, j, k)].QV + Grid3D_prev[torid(QV, i - 1, j, k)].QV) // Diffusion (implicit)
					+ Ky / powf(gridSizeI, 2) * (Grid3D_prev[torid(QV, i, j + 1, k)].QV - 2.0f * Grid3D_prev[torid(QV, i, j, k)].QV + Grid3D_prev[torid(QV, i, j - 1, k)].QV) // Diffusion (implicit)
					+ Kz / powf(gridSizeK[k], 2) * (Grid3D_prev[torid(QV, i, j, k + 1)].QV - 2.0f * Grid3D_prev[torid(QV, i, j, k)].QV + Grid3D_prev[torid(QV, i, j, k - 1)].QV); // d2q/dx2+d2q/dz2

                float nowqv = gridRslow[torid(QV, i, j, k)].QV;

                qc_test =
				gridRslow[torid(QC, i, j, k)].QC =
					-1.0f / gridSizeI * (Grid3D_curr[torid(U, i + 1, j, k)].U * 0.5f * (Grid3D_curr[torid(QC, i + 1, j, k)].QC + Grid3D_curr[torid(QC, i, j, k)].QC)
						- Grid3D_curr[torid(U, i, j, k)].U * 0.5f * (Grid3D_curr[torid(QC, i, j, k)].QC + Grid3D_curr[torid(QC, i - 1, j, k)].QC)) // -duqv/dx

					- 1.0f / gridSizeJ * (Grid3D_curr[torid(V, i, j + 1, k)].V * 0.5f * (Grid3D_curr[torid(QC, i, j + 1, k)].QC + Grid3D_curr[torid(QC, i, j, k)].QC)
						- Grid3D_curr[torid(V, i, j, k)].V * 0.5f * (Grid3D_curr[torid(QC, i, j, k)].QC + Grid3D_curr[torid(QC, i, j - 1, k)].QC)) // -duqv/dx

					- 1.0f / (Grid3D_curr[torid(RO, i, j, k)].RO * gridSizeK[k]) * (
						0.5f * (Grid3D_curr[torid(RO, i, j, k + 1)].RO + Grid3D_curr[torid(RO, i, j, k)].RO) * Grid3D_curr[torid(W, i, j, k + 1)].W * 0.5f * (Grid3D_curr[torid(QC, i, j, k + 1)].QC + Grid3D_curr[torid(QC, i, j, k)].QC)
						- 0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * Grid3D_curr[torid(W, i, j, k)].W * 0.5f * (Grid3D_curr[torid(QC, i, j, k)].QC + Grid3D_curr[torid(QC, i, j, k - 1)].QC)) // -dpwqv/dz
					+ Kx / powf(gridSizeI, 2) * (Grid3D_prev[torid(QC, i + 1, j, k)].QC - 2.0f * Grid3D_prev[torid(QC, i, j, k)].QC + Grid3D_prev[torid(QC, i - 1, j, k)].QC) // Diffusion (implicit)
					+ Ky / powf(gridSizeI, 2) * (Grid3D_prev[torid(QC, i, j + 1, k)].QC - 2.0f * Grid3D_prev[torid(QC, i, j, k)].QC + Grid3D_prev[torid(QC, i, j - 1, k)].QC) // Diffusion (implicit)
					+ Kz / powf(gridSizeK[k], 2) * (Grid3D_prev[torid(QC, i, j, k + 1)].QC - 2.0f * Grid3D_prev[torid(QC, i, j, k)].QC + Grid3D_prev[torid(QC, i, j, k - 1)].QC); // d2q/dx2+d2q/dz2

                qr_test =
				gridRslow[torid(QR, i, j, k)].QR =
					-1.0f / gridSizeI * (Grid3D_curr[torid(U, i + 1, j, k)].U * 0.5f * (Grid3D_curr[torid(QR, i + 1, j, k)].QR + Grid3D_curr[torid(QR, i, j, k)].QR)
						- Grid3D_curr[torid(U, i, j, k)].U * 0.5f * (Grid3D_curr[torid(QR, i, j, k)].QR + Grid3D_curr[torid(QR, i - 1, j, k)].QR)) // -duqv/dx

					- 1.0f / gridSizeJ * (Grid3D_curr[torid(V, i, j + 1, k)].V * 0.5f * (Grid3D_curr[torid(QR, i, j + 1, k)].QR + Grid3D_curr[torid(QR, i, j, k)].QR)
						- Grid3D_curr[torid(V, i, j, k)].V * 0.5f * (Grid3D_curr[torid(QR, i, j, k)].QR + Grid3D_curr[torid(QR, i, j - 1, k)].QR)) // -dvqv/dy

					- 1.0f / (Grid3D_curr[torid(RO, i, j, k)].RO * gridSizeK[k]) * (
						0.5f * (Grid3D_curr[torid(RO, i, j, k + 1)].RO + Grid3D_curr[torid(RO, i, j, k)].RO) * Grid3D_curr[torid(W, i, j, k + 1)].W * 0.5f * (Grid3D_curr[torid(QR, i, j, k + 1)].QR + Grid3D_curr[torid(QR, i, j, k)].QR)
						- 0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * Grid3D_curr[torid(W, i, j, k)].W * 0.5f * (Grid3D_curr[torid(QR, i, j, k)].QR + Grid3D_curr[torid(QR, i, j, k - 1)].QR)) // -dpwqv/dz
					+ Kx / powf(gridSizeI, 2) * (Grid3D_prev[torid(QR, i + 1, j, k)].QR - 2.0f * Grid3D_prev[torid(QR, i, j, k)].QR + Grid3D_prev[torid(QR, i - 1, j, k)].QR) // Diffusion (implicit)
					+ Ky / powf(gridSizeI, 2) * (Grid3D_prev[torid(QR, i, j + 1, k)].QR - 2.0f * Grid3D_prev[torid(QR, i, j, k)].QR + Grid3D_prev[torid(QR, i, j - 1, k)].QR) // Diffusion (implicit)
					+ Kz / powf(gridSizeK[k], 2) * (Grid3D_prev[torid(QR, i, j, k + 1)].QR - 2.0f * Grid3D_prev[torid(QR, i, j, k)].QR + Grid3D_prev[torid(QR, i, j, k - 1)].QR); // d2q/dx2+d2q/dz2

                gridRslow[torid(RO, i, j, k)].RO = 0.0f;

				//for quick verification
                Step1TestTotal += gridRslow[torid(U, i, j, k)].U + gridRslow[torid(V, i, j, k)].V + gridRslow[torid(W, i, j, k)].W
					+ gridRslow[torid(THETA, i, j, k)].THETA + gridRslow[torid(Pi, i, j, k)].Pi
					+ gridRslow[torid(QV, i, j, k)].QV + gridRslow[torid(QC, i, j, k)].QC + gridRslow[torid(QR, i, j, k)].QR;


            }
        }
    }
    //if (Step1TestTotal != 0)
    //{
    //    UE_LOG(WeatherManager, Display, TEXT("\n //////////////////////////// Step1 Test Total  '%f'"), Step1TestTotal);
    //}
    return Step1TestTotal;
}
/* STEP2: Kelsner Microphicis */
float simulateSTEP2()
{

    float QV_Test = 0;
    float QC_Test = 0;
    float QR_Test = 0;
    float THETA_Test = 0;
    float Step2TestTotal = 0;

    for (int k = 1; k < gridZ - 1; k++)
    {
        for (int j = 0; j < gridY; j++)
        {
            for (int i = 0; i < gridX; i++)
            {

				// Kessler microphysics.
				// A = max[ k1 * (qc-qc0) , 0 ] : autoconverstion qc -> qr
				// B = k2 * qc * qr^7/8	: accretion qc -> qr
				// C: condensation ; qv <-> qv
				// E: evaporation ; qr -> qv
				// All values from t-1 step
				// Order of calculation matters here

                float A_conv = 0.0;
                if (Grid3D_prev[torid(QC, i, j, k)].QC > 0.001)
                    A_conv = max /*<float>*/(0.0f, 0.001 * (Grid3D_prev[torid(QC, i, j, k)].QC - 0.001)); // conversion cloud -> rain

                float B_acc = max /*<float>*/(0.0f, gridInit[torid(RO, i, j, k)].RO * 2.2f * Grid3D_prev[torid(QC, i, j, k)].QC * powf(Grid3D_prev[torid(QR, i, j, k)].QR, 0.875f)); // accretion cloud -> rain

                A_conv *= /*st.*/rainProbability;
                B_acc *= /*st.*/rainProbability;

				// Saturation adjustment (Soong & Ogura)
                float pmean = powf(gridInit[torid(Pi, i, j, k)].Pi, cpd / Rd) * p_0; // Mean pressure
                float qvs = (380.0f / pmean) * exp(7.5f * log(10.0f) *
					((Grid3D_prev[torid(THETA, i, j, k)].THETA + gridInit[torid(THETA, i, j, k)].THETA) * ((Grid3D_prev[torid(Pi, i, j, k)].Pi + gridInit[torid(Pi, i, j, k)].Pi)) - 273.0f) /
					((Grid3D_prev[torid(THETA, i, j, k)].THETA + gridInit[torid(THETA, i, j, k)].THETA) * ((Grid3D_prev[torid(Pi, i, j, k)].Pi + gridInit[torid(Pi, i, j, k)].Pi)) - 36.0f)); // Saturation mixing ratio
                Grid3D_prev[torid(QV, i, j, k)].QV = max /*<float>*/(Grid3D_prev[torid(QV, i, j, k)].QV, -1.0f * gridInit[torid(QV, i, j, k)].QV); // remove negative values
                float rsub = qvs * (7.5f * logf(10.0f) * (273.0f - 36.0f) * Llv / cpd) /
					powf(gridInit[torid(Pi, i, j, k)].Pi * (Grid3D_prev[torid(THETA, i, j, k)].THETA + gridInit[torid(THETA, i, j, k)].THETA), 2);

                float Cond = min /*<float>*/(Grid3D_prev[torid(QV, i, j, k)].QV + gridInit[torid(QV, i, j, k)].QV,
					max /*<float>*/(0.0f, ((Grid3D_prev[torid(QV, i, j, k)].QV + gridInit[torid(QV, i, j, k)].QV) - qvs) / (1.0f + rsub))); // Condensation (qv -> qc)

                float Cvent = 1.6f + 124.9f * powf(gridInit[torid(RO, i, j, k)].RO * Grid3D_prev[torid(QC, i, j, k)].QC, 0.2046f); // ventillation factor
                float Evap = min /*<float>*/(min /*<float>*/(Grid3D_prev[torid(QR, i, j, k)].QR, max /*<float>*/(-1.0f * Cond - Grid3D_prev[torid(QC, i, j, k)].QC, 0.0f)), // 3 options
                dT * Cvent * powf(gridInit[torid(RO, i, j, k)].RO * Grid3D_prev[torid(QR, i, j, k)].QR, 0.525f) / (5.4e5 + 2.55e8 / (pmean * qvs))
					* max /*<float>*/(qvs - Grid3D_prev[torid(QV, i, j, k)].QV, 0.0f) / (gridInit[torid(RO, i, j, k)].RO * qvs));
                Cond = max /*<float>*/(Cond, -1.0f * Grid3D_prev[torid(QC, i, j, k)].QC);

                float nowqv = gridRslow[torid(QV, i, j, k)].QV;
                QV_Test =
				gridRslow[torid(QV, i, j, k)].QV = gridRslow[torid(QV, i, j, k)].QV - Cond + Evap; // Net mass conversion

                QC_Test =
				gridRslow[torid(QC, i, j, k)].QC = gridRslow[torid(QC, i, j, k)].QC + Cond - A_conv - B_acc; // Net mass conversion

                float vterm0 = 36.34f * sqrtf(gridInit[torid(RO, i, j, 0)].RO / gridInit[torid(RO, i, j, k)].RO) * powf(max /*<float>*/(gridInit[torid(RO, i, j, k)].RO * Grid3D_prev[torid(QR, i, j, k)].QR, 0.0f), 0.1364f);
                float vterm1 = 36.34f * sqrtf(gridInit[torid(RO, i, j, 0)].RO / gridInit[torid(RO, i, j, k + 1)].RO) * powf(max /*<float>*/(gridInit[torid(RO, i, j, k + 1)].RO * Grid3D_prev[torid(QR, i, j, k + 1)].QR, 0.0f), 0.1364f); // vT terminal velocity
				// note, it's possible that vT > CFL.

                QR_Test =
				gridRslow[torid(QR, i, j, k)].QR = gridRslow[torid(QR, i, j, k)].QR + A_conv + B_acc - Evap // Net mass change
					+ 1.0f / (Grid3D_curr[torid(RO, i, j, k)].RO * gridSizeK[k]) * (
						0.5f * (Grid3D_curr[torid(RO, i, j, k + 1)].RO + Grid3D_curr[torid(RO, i, j, k)].RO) * vterm1 * 0.5f * (Grid3D_prev[torid(QR, i, j, k + 1)].QR + Grid3D_prev[torid(QR, i, j, k)].QR)
						- 0.5f * (Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_curr[torid(RO, i, j, k - 1)].RO) * vterm0 * 0.5f * (Grid3D_prev[torid(QR, i, j, k)].QR + Grid3D_prev[torid(QR, i, j, k - 1)].QR)); // Falling rain

                THETA_Test =
				gridRslow[torid(THETA, i, j, k)].THETA = gridRslow[torid(THETA, i, j, k)].THETA + Llv / (cpd * gridInit[torid(Pi, i, j, k)].Pi) * (Cond - Evap); // latent heating Lv/(cpd * P) * (C-E);



                //for quick verification
                Step2TestTotal += gridRslow[torid(THETA, i, j, k)].THETA
					+ gridRslow[torid(QV, i, j, k)].QV + gridRslow[torid(QC, i, j, k)].QC + gridRslow[torid(QR, i, j, k)].QR;

            }
        }
    }
    //if (Step2TestTotal != 0)
    //{
    //    UE_LOG(WeatherManager, Display, TEXT("\n //////////////////////////// Step2 Test Total  '%f'"), Step2TestTotal);
    //}
    return Step2TestTotal;

}
/* STEP3: Move forward in time */
float simulateSTEP3()
{

    float u_next_test = 0;
    float v_next_test = 0;
    float w_next_test = 0;
    float pi_next_test = 0;
    float theta_next_test = 0;
    float qv_next_test = 0;
    float qc_next_test = 0;
    float qr_next_test = 0;
    float ro_next_test = 0;

    float u_curr_test = 0;
    float v_curr_test = 0;
    float w_curr_test = 0;
    float pi_curr_test = 0;
    float theta_curr_test = 0;
    float qv_curr_test = 0;
    float qc_curr_test = 0;
    float qr_curr_test = 0;
    float ro_curr_test = 0;
    float Step3TestTotal = 0;

    for (int k = 1; k < gridZ - 1; k++)
    {
        for (int j = 0; j < gridY; j++)
        {
            for (int i = 0; i < gridX; i++)
            {

                if (simulationTime == 0.0f)
                { // 1st step: forward in time
				  //	printf("first Iteration\n");
                    u_next_test = Grid3D_next[torid(U, i, j, k)].U = Grid3D_curr[torid(U, i, j, k)].U + dT * gridRslow[torid(U, i, j, k)].U;
                    v_next_test = Grid3D_next[torid(V, i, j, k)].V = Grid3D_curr[torid(V, i, j, k)].V + dT * gridRslow[torid(V, i, j, k)].V;
                    w_next_test = Grid3D_next[torid(W, i, j, k)].W = Grid3D_curr[torid(W, i, j, k)].W + dT * gridRslow[torid(W, i, j, k)].W;
                    if ((k < 2))
                    {
                        w_next_test = Grid3D_next[torid(W, i, j, k)].W = 0.0f; // top & bottom BCs //|| (k==zEnd)
                    }
                    if ((w_next_test == 0.5 || w_next_test == 0))
                    {
                        int testtest = 1;
                    }
                    else
                    {
                        int testtest = 1;
                    }
                    pi_next_test = Grid3D_next[torid(Pi, i, j, k)].Pi = Grid3D_curr[torid(Pi, i, j, k)].Pi + dT * gridRslow[torid(Pi, i, j, k)].Pi;
                    theta_next_test = Grid3D_next[torid(THETA, i, j, k)].THETA = Grid3D_curr[torid(THETA, i, j, k)].THETA + dT * gridRslow[torid(THETA, i, j, k)].THETA;
                    qv_next_test = Grid3D_next[torid(QV, i, j, k)].QV = Grid3D_curr[torid(QV, i, j, k)].QV + dT * gridRslow[torid(QV, i, j, k)].QV;
                    qc_next_test = Grid3D_next[torid(QC, i, j, k)].QC = Grid3D_curr[torid(QC, i, j, k)].QC + dT * gridRslow[torid(QC, i, j, k)].QC;
                    qr_next_test = Grid3D_next[torid(QR, i, j, k)].QR = Grid3D_curr[torid(QR, i, j, k)].QR + dT * gridRslow[torid(QR, i, j, k)].QR;
                    ro_next_test = Grid3D_next[torid(RO, i, j, k)].RO = Grid3D_curr[torid(RO, i, j, k)].RO + dT * gridRslow[torid(RO, i, j, k)].RO;

                }
                else
                { // subsequent steps: leapfrog

					//	printf("No first Iteration\n");
                    u_next_test = Grid3D_next[torid(U, i, j, k)].U = Grid3D_prev[torid(U, i, j, k)].U + 2.0f * dT * gridRslow[torid(U, i, j, k)].U;
                    v_next_test = Grid3D_next[torid(V, i, j, k)].V = Grid3D_prev[torid(V, i, j, k)].V + 2.0f * dT * gridRslow[torid(V, i, j, k)].V;
                    w_next_test = Grid3D_next[torid(W, i, j, k)].W = Grid3D_prev[torid(W, i, j, k)].W + 2.0f * dT * gridRslow[torid(W, i, j, k)].W;
                    if ((k < 2))
                    {
                        w_next_test = Grid3D_next[torid(W, i, j, k)].W = 0.0f; // top & bottom BCs // || (k==zEnd)
                    }
                    if ((w_next_test == 0.5 || w_next_test == 0))
                    {
                        int testtest = 1;
                    }
                    else
                    {
                        int testtest = 1;
                    }
                    pi_next_test = Grid3D_next[torid(Pi, i, j, k)].Pi = Grid3D_prev[torid(Pi, i, j, k)].Pi + 2.0f * dT * gridRslow[torid(Pi, i, j, k)].Pi;
                    theta_next_test = Grid3D_next[torid(THETA, i, j, k)].THETA = Grid3D_prev[torid(THETA, i, j, k)].THETA + 2.0f * dT * gridRslow[torid(THETA, i, j, k)].THETA;
                    qv_next_test = Grid3D_next[torid(QV, i, j, k)].QV = Grid3D_prev[torid(QV, i, j, k)].QV + 2.0f * dT * gridRslow[torid(QV, i, j, k)].QV;
                    qc_next_test = Grid3D_next[torid(QC, i, j, k)].QC = Grid3D_prev[torid(QC, i, j, k)].QC + 2.0f * dT * gridRslow[torid(QC, i, j, k)].QC;
                    qr_next_test = Grid3D_next[torid(QR, i, j, k)].QR = Grid3D_prev[torid(QR, i, j, k)].QR + 2.0f * dT * gridRslow[torid(QR, i, j, k)].QR;
                    ro_next_test = Grid3D_next[torid(RO, i, j, k)].RO = Grid3D_prev[torid(RO, i, j, k)].RO + 2.0f * dT * gridRslow[torid(RO, i, j, k)].RO;

					// Roberts-Asselin filter
                    u_curr_test += Grid3D_curr[torid(U, i, j, k)].U = Grid3D_curr[torid(U, i, j, k)].U + 0.1f * (Grid3D_next[torid(U, i, j, k)].U - 2.0f * Grid3D_curr[torid(U, i, j, k)].U + Grid3D_prev[torid(U, i, j, k)].U);
                    v_curr_test += Grid3D_curr[torid(V, i, j, k)].V = Grid3D_curr[torid(V, i, j, k)].V + 0.1f * (Grid3D_next[torid(V, i, j, k)].V - 2.0f * Grid3D_curr[torid(V, i, j, k)].V + Grid3D_prev[torid(V, i, j, k)].V);

                    int test = torid(W, i, j, k);
                    w_curr_test += Grid3D_curr[torid(W, i, j, k)].W = Grid3D_curr[torid(W, i, j, k)].W + 0.1f * (Grid3D_next[torid(W, i, j, k)].W - 2.0f * Grid3D_curr[torid(W, i, j, k)].W + Grid3D_prev[torid(W, i, j, k)].W);
					
                    pi_curr_test += Grid3D_curr[torid(THETA, i, j, k)].THETA = Grid3D_curr[torid(THETA, i, j, k)].THETA + 0.1f * (Grid3D_next[torid(THETA, i, j, k)].THETA - 2.0f * Grid3D_curr[torid(THETA, i, j, k)].THETA + Grid3D_prev[torid(THETA, i, j, k)].THETA);
                    theta_curr_test += Grid3D_curr[torid(Pi, i, j, k)].Pi = Grid3D_curr[torid(Pi, i, j, k)].Pi + 0.1f * (Grid3D_next[torid(Pi, i, j, k)].Pi - 2.0f * Grid3D_curr[torid(Pi, i, j, k)].Pi + Grid3D_prev[torid(Pi, i, j, k)].Pi);
                    qv_curr_test += Grid3D_curr[torid(QV, i, j, k)].QV = Grid3D_curr[torid(QV, i, j, k)].QV + 0.1f * (Grid3D_next[torid(QV, i, j, k)].QV - 2.0f * Grid3D_curr[torid(QV, i, j, k)].QV + Grid3D_prev[torid(QV, i, j, k)].QV);
                    qc_curr_test += Grid3D_curr[torid(QC, i, j, k)].QC = Grid3D_curr[torid(QC, i, j, k)].QC + 0.1f * (Grid3D_next[torid(QC, i, j, k)].QC - 2.0f * Grid3D_curr[torid(QC, i, j, k)].QC + Grid3D_prev[torid(QC, i, j, k)].QC);
                    qr_curr_test += Grid3D_curr[torid(QR, i, j, k)].QR = Grid3D_curr[torid(QR, i, j, k)].QR + 0.1f * (Grid3D_next[torid(QR, i, j, k)].QR - 2.0f * Grid3D_curr[torid(QR, i, j, k)].QR + Grid3D_prev[torid(QR, i, j, k)].QR);
                    ro_curr_test += Grid3D_curr[torid(RO, i, j, k)].RO = Grid3D_curr[torid(RO, i, j, k)].RO + 0.1f * (Grid3D_next[torid(RO, i, j, k)].RO - 2.0f * Grid3D_curr[torid(RO, i, j, k)].RO + Grid3D_prev[torid(RO, i, j, k)].RO);

                }
				//for quick verification
                Step3TestTotal +=
					u_next_test
					+ v_next_test
					+ w_next_test
					+ pi_next_test
					+ theta_next_test
					+ qv_next_test
					+ qc_next_test
					+ qr_next_test
					+ ro_next_test;
                Step3TestTotal +=
					u_curr_test
					+ v_curr_test
					+ w_curr_test
					+ pi_curr_test
					+ theta_curr_test
					+ qv_curr_test
					+ qc_curr_test
					+ qr_curr_test
					+ ro_curr_test;
            }
        }
    }
    //if (Step3NextTestTotal != 0)
    //{
    //    UE_LOG(WeatherManager, Display, TEXT("\n //////////////////////////// Step3 Next Test Total  '%f'"), Step3NextTestTotal);
    //}
    //if (Step3CurrTestTotal != 0)
    //{
    //    UE_LOG(WeatherManager, Display, TEXT("\n //////////////////////////// Step3 Curr Test Total  '%f'"), Step3CurrTestTotal);
    //}
    return Step3TestTotal;

}
/* STEP4: Radiation model */
float simulateSTEP4()
{

    float gr_cloud_cover = 0;
    float theta_next_test = 0;
    float gr_tg_test = 0;
    float gr_ta_test = 0;
    float gr_tg_reset = 0;
    float gr_ta_reset = 0;
    float gr_ta_corr = 0;
    float Step4TestTotal = 0;

    for (int j = 0; j < gridY; j++)
    {
        for (int i = 0; i < gridX; i++)
        {

            const float T_M = 29.0f + 273.15f; // Invariable slab temperature //INIT 10.0f 32.0f
            const float dur = 3600.0f * 24.0f; // * 5.0f;//24h
            const float S_const = -1.127f; //Solar constant km/s

			////////////////////////////////////////
			// INIT VALUES
            if (simulationTime == 0.0f)
            { // 1st step: forward in time 
                Grid3D_curr[torid(THETA, i, j, 0)].THETA = 0;

                ground[torid_ground(i, j)].GR_TG = 23.5f + 273.15f;
                ground[torid_ground(i, j)].GR_TA = gridInit[torid(THETA, i, j, 0)].THETA;

                ground[torid_ground(i, j)].GR_TG_RESET = FLT_MAX; // INF

                ground[torid_ground(i, j)].GR_TG_CORR = 0.0f;
                ground[torid_ground(i, j)].GR_TA_CORR = 0.0f;

                ground[torid_ground(i, j)].GR_CLOUD_COVER = 0.0f;
            }


			////////////////////////////////////////
			// CLOUD COVERAGE

            if ((int(simulationTime / dT) % (60 * 5)) == 0)
            { // each 300 steps
                float cloudTotal = 0.0f;
                for (int z = /*static_cast<int>*/(0.33f * gridZ); z < /*static_cast<int>*/(0.83f * gridZ); z++)
                {
                    float density = Grid3D_next[torid(QC, i, j, z)].QC;
                    if (density == 0.0f)
                        continue;
                    if (density > 2e-3f)
                    {
                        density = 0.99f;
                    }
                    else
                    {
                        if (density < 1e-3f)
                        {
                            density = 0.0f;
                        }
                        else
                        {
                            density = -1520000.0f * (density * density) + 5360.00f * (density) - 3.74f;
                        }
                    }
                    cloudTotal += density * 0.1f; //0.05f so it has soft borders
                    if (cloudTotal >= 1.0f)
                    {
                        break; // not necessary to check more
                    }
                }
                gr_cloud_cover =
					ground[torid_ground(i, j)].GR_CLOUD_COVER = fmin(cloudTotal, 1.0f);
            }



			////////////////////////////////////////
			// UTC
            float t_UTC = /*st.*/initTimeUTC_hours + (simulationTime / 3600.0f); //day overflow
            int advancedDays = int(t_UTC / (24.0f)); //full days
            float dayInYearUTC = /*st.*/initDayInYearUTC + advancedDays;
            while (dayInYearUTC > 365)
                dayInYearUTC -= 365;
            t_UTC -= advancedDays * 24.0f;

			////////////////////////////////////////
			// LOCAL
            float t_Local = t_UTC + /*st.*/timeZone;
            if (t_Local < 0.0f)
                t_Local += 24.0f;
            if (t_Local > 24.0f)
                t_Local -= 24.0f;


            float lat = /*st.*/latitudeRad;
            float longi = - /*st.*/longitudeRad; //note NEGATE (West)

            float delta = 0.409f * cos((2.0f * M_PI) * (dayInYearUTC - 173.0f) / (365.25f)); //d_s: solarDeclineAngle
            float sinPSI = sin(lat) * sin(delta) - cos(lat) * cos(delta) * cos(((M_PI * t_UTC) / 12.0f) - longi);

            float gamma = 0.0000010717f * powf(t_Local, 5.0f) + 0.0000818369f * powf(t_Local, 4.0f) - 0.0060500842f * powf(t_Local, 3.0f) + 0.0772306397f * powf(t_Local, 2.0f) + 0.1444444444f * t_Local - 1.8441558442f;

			////////////////////////////////////////
			// RADITATION

            float alb = ground[torid_ground(i, j)].GR_ALBEDO;
            float c_g_a = ground[torid_ground(i, j)].GR_CGA;

            float sig_l = ground[torid_ground(i, j)].GR_CLOUD_COVER;
            float sig_m = ground[torid_ground(i, j)].GR_CLOUD_COVER;
            const float sig_h = 0.1f;

            float I = 0.08f * (1.0f - 0.1f * sig_h - 0.3f * sig_m - 0.6f * sig_l);

            float Tk = (0.6f + 0.2f * sinPSI) * (1.0f - 0.4f * sig_h) * (1.0f - 0.7f * sig_m) * (1.0f - 0.4f * sig_l); //trans
            float Q_net = (1.0f - alb) * S_const * Tk * sinPSI + I;
            if (sinPSI < 0)
                Q_net = I;
            float a_fr;
            if (ground[torid_ground(i, j)].GR_TG > ground[torid_ground(i, j)].GR_TA)
            {
				//DAY
                a_fr = 3e-4f;
            }
            else
            {
				//NIGHT
                a_fr = 1.1e-4f;
            }


            float T_G_t = ((-Q_net / c_g_a) + (2.0f * M_PI / dur * (T_M - ground[torid_ground(i, j)].GR_TG)) - (a_fr * (ground[torid_ground(i, j)].GR_TG - ground[torid_ground(i, j)].GR_TA)));
            float Q_g = -1.0f * ((c_g_a * T_G_t) + (2.0f * M_PI * c_g_a / dur * (ground[torid_ground(i, j)].GR_TG - T_M))); //Units are fomd
            float Q_h = (-Q_net + Q_g) / ground[torid_ground(i, j)].GR_BETA_INV;

            gr_tg_test =
				ground[torid_ground(i, j)].GR_TG += (dT * T_G_t) + ground[torid_ground(i, j)].GR_TG_CORR; // NEW TG
            gr_ta_test =
				ground[torid_ground(i, j)].GR_TA += (dT * Q_h * 1.0e-3f) + ground[torid_ground(i, j)].GR_TA_CORR; // Introduced this new time parameterization //NEW TA


			///////////////////////////////////
			// STEP 0: Save ref value after 2 hours of simulation
            if ((ground[torid_ground(i, j)].GR_TG_RESET == FLT_MAX) && (simulationTime >= 3600.0f * 2.0f))
            { // put first FLT_MAX to avoid to comparisons
                gr_tg_reset =
					ground[torid_ground(i, j)].GR_TG_RESET = ground[torid_ground(i, j)].GR_TG;
                gr_ta_reset =
					ground[torid_ground(i, j)].GR_TA_RESET = ground[torid_ground(i, j)].GR_TA;
                if (i == 0 && j == 0)
                {
					//printf("** Save Ref: %f (%.2f)\n", simulationTime, simulationTime / 3600.0f);
                }
            }


			///////////////////////////////////
			// STEP1: Update Correction after Each 24hours (+2h)
            if ((simulationTime >= 3600.0f * (2.0f + 24.0f)) && ((int(simulationTime) - 2 * 3600)) % (24 * 3600) == 0)
            { // RESET
                if (i == 0)
                {
					//printf("** Reset: %f (%f)\n", simulationTime, simulationTime / 3600.0f);
                }
                float TG_diff = ground[torid_ground(i, j)].GR_TG_RESET - ground[torid_ground(i, j)].GR_TG;
                float TA_diff = ground[torid_ground(i, j)].GR_TA_RESET - ground[torid_ground(i, j)].GR_TA;
                ground[torid_ground(i, j)].GR_TG_CORR = (TG_diff / (24.0f * 3600.0f)) * dT * 1.2f; //1.2f correction factor
                gr_ta_corr =
					ground[torid_ground(i, j)].GR_TA_CORR = (TA_diff / (24.0f * 3600.0f)) * dT * 1.2f;
            }

            theta_next_test =
				Grid3D_next[torid(THETA, i, j, 0)].THETA = ground[torid_ground(i, j)].GR_TA + gamma * gridSizeK[0] / 100.0f - gridInit[torid(THETA, i, j, 0)].THETA; //transfer of Ta to THETA

            Step4TestTotal +=
				+gr_cloud_cover
				+ theta_next_test
				+ gr_tg_test
				+ gr_ta_test
				+ gr_tg_reset
				+ gr_ta_reset
				+ gr_ta_corr;
        }
    }


    //if (Step4TestTotal != 0)
    //{
    //    UE_LOG(WeatherManager, Display, TEXT("\n //////////////////////////// Step4 Test Total  '%f'"), Step4TestTotal);
    //}
    return Step4TestTotal;

}

///////////////////////////////////////////////////////////////////////////

//float1 StepTotal = 0;

RWTexture2D<float4> OutputTexture;//: register(u0);
//RWTexture3D<float4>	OutputColor;

//void MainComputeShader(uint3 Gid : SV_GroupID, //atm: -, 0...256, - in rows (Y)        --> current group index (dispatched by c++)
//                       uint3 DTid : SV_DispatchThreadID, //atm: 0...256 in rows & columns (XY)   --> "global" thread id
//                       uint3 GTid : SV_GroupThreadID, //atm: 0...256, -,- in columns (X)      --> current threadId in group / "local" threadId
//                       uint GI : SV_GroupIndex)            //atm: 0...256 in columns (X)           --> "flattened" index of a thread within a group

// RUN SIMULATION
[numthreads(32, 32, 1)]
void simulateStep(uint GroupIndex : SV_GroupIndex, uint3 DispatchThreadId : SV_DispatchThreadID)
{
    float2 TextureSize = (512.0, 512.0);
   


	// Set up some variables we are going to need
    float2 iResolution = float2(TextureSize.x, TextureSize.y);
    float2 uv = (DispatchThreadId.xy / iResolution.xy) - 0.5;
    float iGlobalTime = simulationTime;

	// This shader code is from www.shadertoy.com, converted to HLSL by me. If you have not checked out shadertoy yet, you REALLY should!!
    float t = iGlobalTime * 0.1 + ((0.25 + 0.05 * sin(iGlobalTime * 0.1)) / (length(uv.xy) + 0.07)) * 2.2;
    float si = sin(t);
    float co = cos(t);
    float2x2 ma = { co, si, -si, co };

    float v1, v2, v3;
    v1 = v2 = v3 = 0.0;

    float s = 0.0;
    for (int i = 0; i < 90; i++)
    {
        float3 p = s * float3(uv, 0.0);
        p.xy = mul(p.xy, ma);
        p += float3(0.22, 0.3, s - 1.5 - sin(iGlobalTime * 0.13) * 0.1);
		
        for (int i = 0; i < 8; i++)	
            p = abs(p) / dot(p, p) - 0.659;

        v1 += dot(p, p) * 0.0015 * (1.8 + sin(length(uv.xy * 13.0) + 0.5 - iGlobalTime * 0.2));
        v2 += dot(p, p) * 0.0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iGlobalTime * 0.3));
        v3 += length(p.xy * 10.0) * 0.0003;
        s += 0.035;
    }

    float len = length(uv);
    v1 *= lerp(0.7, 0.0, len);
    v2 *= lerp(0.5, 0.0, len);
    v3 *= lerp(0.9, 0.0, len);

    float3 col = float3(v3 * (1.5 + sin(iGlobalTime * 0.2) * 0.4), (v1 + v3) * 0.3, v2)
					+ lerp(0.2, 0.0, len) * 0.85
					+ lerp(0.0, 0.6, v3) * 0.3;

    float3 powered = pow(abs(col), float3(1.2, 1.2, 1.2));
    float3 minimized = min(powered, 1.0);
    float4 outputColor = float4(minimized, 1.0);

	// Since there are limitations on operations that can be done on certain formats when using compute shaders
	// I elected to go with the most flexible one (UINT 32bit) and do my packing manually to simulate an R8G8B8A8_UINT format.
	// There might be better ways to do this :)
    //uint r = outputColor.r * 255.0;
    //uint g = ((uint) (outputColor.g * 255.0)) << 8;
    //uint b = ((uint) (outputColor.b * 255.0)) << 16;
    //uint a = ((uint) (outputColor.a * 255.0)) << 24;
	
    OutputTexture[DispatchThreadId.xy] = float4(outputColor.r, outputColor.g, outputColor.b, outputColor.a);
    
    
    
    
    
    
    
    
    
    
    
    float Step1TestTotal = 0;
    float Step2TestTotal = 0;
    float Step3TestTotal = 0;
    float Step4TestTotal = 0;

    // Fundamental equations.
    //Step1TestTotal = simulateSTEP1();
    
    // Microphysics.
    //Step2TestTotal = simulateSTEP2();

    // Move in time.
    //Step3TestTotal = simulateSTEP3();

    // Radiation.
    //Step4TestTotal = simulateSTEP4();

    //StepTotal[0] += Step1TestTotal + Step2TestTotal + Step3TestTotal + Step4TestTotal;
    //[loop]
    //for (int j = 0; j < 512; j++)
    //{[loop]
    //    for (int y = 0; y < 512; y++)
    //    {
    //        float r = 1 * 255.0;
    //        float g = 1 * 255.0;
    //        float b = 1 * 255.0;
    //        float a = 1 * 255.0;
            
	
    //        //OutputTexture[float2(j, y)] = r | g | b | a;
    //        OutputTexture[int2(j, y)] = float4(r, g, b, a);
    //    }
    //}
    
    //for (int i = 0; i < 512; ++i)
    //{
    //    for (int j = 0; j < 512; ++j)
    //    {
    //        uint2 loc = uint2(float(i) / 512.f, float(j) / 512.f);
    //        OutputTexture[loc.xy] = (i * j) % 2 ? float4(0.5f, 0.6f, 0.7f, 1.f) : float4(0.7f, 0.6f, 0.5f, 1.f);
    //    }
    //}
    
   // GroupMemoryBarrierWithGroupSync();

    //simulationTime += dT;

}