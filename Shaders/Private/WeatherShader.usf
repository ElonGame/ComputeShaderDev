//Reference LICENSE_2 for the simulation code contained in here!
#pragma once
//#include "/Engine/Private/Common.ush"
#include "WeatherConstantProperties.ush"
#include "WeatherVariableProperties.ush"
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ShaderPrintCommon.ush" //<-Ignore the errors this works fine

//Tricks so i don't have to re-write the c++ struct accessor functions
#define gridRslow(col, i, j, k) gridRslow[GetAirIndex(col, i, j, k)].CellColumns.col

#define gridInit(col, i, j, k) gridInit[GetAirIndex(col, i, j, k)].CellColumns.col
#define currGrid3D(col, i, j, k) grid3D[GetGridIndex(currGC)+GetAirIndex(col, i, j, k)].CellColumns.col
#define prevGrid3D(col, i, j, k) grid3D[GetGridIndex(prevGC)+GetAirIndex(col, i, j, k)].CellColumns.col
#define nextGrid3D(col, i, j, k) grid3D[GetGridIndex(nextGC)+GetAirIndex(col, i, j, k)].CellColumns.col
#define ground(col, i, j) ground[GetGroundIndex(col, i, j)].CellColumns.col

//More tricks to keep original code
#define FLT_MAX 3.402823466e+38F
#define powf pow
#define logf log
#define fmin min
#define sqrtf sqrt
//first rename gridSizeK[k] with gridSizeK(k)
#define gridSizeK(k) gridSizeK[k].Cell

//int GetGridIndex(int arr)
//{
//    return gridX * gridY * gridZ * arr;
//}


//int GetAirIndex(int arr, int x, int y, int z)
//{

//    float result;



//    int aI = x; // Toroidal behavior: (x<0)-->(x=gridX-1-x) and (x>gridX-1)-->(x=x-gridX-1)
//    if (aI < 0)
//        {
//            aI = gridX + x;
//        }

//    if (aI >= gridX)
//        {
//            aI = (x % gridX);
//        }

//    int aJ = y; // Toroidal
//    if (aJ < 0)
//        {
//            aJ = gridY + y;
//        }

//    if (aJ >= gridY)
//        {
//            aJ = (y % gridY);
//        }

//    int aZ = z;
//    int gridK = gridZ;

//    if (arr == W)
//        {
//            gridK++;
//        }
       

//    aZ = max(0, aZ); //not under
//    aZ = min(aZ, gridK - 2); //not over top


//    if ((z < 0 || z >= gridK) && (arr <= 2 || arr == 8))
//        { //for values (under z<0, or higher than the gridK) AND they are arr<=2 (u,v,w) or arr==8 (rL)
//            result = 0.0f;
//        }
//        else
//        {
//        result = aI + aJ * gridX + aZ * (gridX * gridY);
//        }
//    return result;
//}

//	/* Operators to acces the data in a toroidal manner */
//int GetGroundIndex(int arr, int x, int y)
//{


//    int aY = y; // toroidal behavior
//    if (y < 0)
//        {
//        aY = gridY + y;
//        }
//    if (y >= gridY)
//    {
//        aY = (y % gridY);
//    }

//    int aX = x; // toroidal behavior
//    if (x < 0)
//    {
//        aX = gridX + x;
//    }
//    if (x >= gridX)
//    {
//        aX = (x % gridX);
//    }
//    return aX + aY * gridY;
//}

 
/////////////////////////////////////////
//// SIMULATION STEPS

///* STEP 1 Fundamental Equations */
//void simulateSTEP1()
//{

//    [loop]
//    for (int k = 0; k < gridZ - 1; k++)
//    {
//        int km1 = k - 1;
//        if (km1 < 0)
//        {
//            km1 = 0;
//        }
//        [loop]
//        for (int j = 0; j < gridY; j++)
//        {
//            [loop]
//            for (int i = 0; i < gridX; i++)
//            {
//                gridRslow(U, i, j, k) =
//                -1.0f / gridSizeI * (powf(0.5f * (currGrid3D(U, i + 1, j, k) + currGrid3D(U, i, j, k)), 2) - powf(0.5f * (currGrid3D(U, i, j, k) + currGrid3D(U, i - 1, j, k)), 2)) // -duu/dx

//                - 1.0f / gridSizeJ * (
//                0.5f * (currGrid3D(U, i, j + 1, k) + currGrid3D(U, i, j, k)) * 0.5f * (currGrid3D(V, i, j + 1, k) + currGrid3D(V, i - 1, j + 1, k))
//                - 0.5f * (currGrid3D(U, i, j, k) + currGrid3D(U, i, j - 1, k)) * 0.5f * (currGrid3D(V, i, j, k) + currGrid3D(V, i - 1, j, k))) // -duv/dy

//                - 1.0f / (currGrid3D(RO, i, j, k) * gridSizeK(k)) * (
//                0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * 0.5f * (currGrid3D(W, i, j, k + 1) + currGrid3D(W, i - 1, j, k + 1)) * 0.5f * (currGrid3D(U, i, j, k + 1) + currGrid3D(U, i, j, k))
//                - 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * 0.5f * (currGrid3D(W, i, j, k) + currGrid3D(W, i - 1, j, k)) * 0.5f * (currGrid3D(U, i, j, k - 1) + currGrid3D(U, i, j, k))) // -dpuw/dz
//                - 1.0f / gridSizeI * (cpd * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k)) * (currGrid3D(Pi, i, j, k) - currGrid3D(Pi, i - 1, j, k))) // -cpd*T*dP/dx
//                + Kx / powf(gridSizeI, 2) * (prevGrid3D(U, i + 1, j, k) - 2.0f * prevGrid3D(U, i, j, k) + prevGrid3D(U, i - 1, j, k))
//                + Ky / powf(gridSizeJ, 2) * (prevGrid3D(U, i, j + 1, k) - 2.0f * prevGrid3D(U, i, j, k) + prevGrid3D(U, i, j - 1, k))
//                + Kz / powf(gridSizeK(k), 2) * ((prevGrid3D(U, i, j, k + 1) - gridInit(U, i, j, k + 1)) - 2.0f * (prevGrid3D(U, i, j, k) - gridInit(U, i, j, k)) + (prevGrid3D(U, i, j, k - 1) - gridInit(U, i, j, k - 1))); // Diffusion (implicit)


//                gridRslow(V, i, j, k) =
//                -1.0f / gridSizeI * (
//                0.5f * (currGrid3D(V, i + 1, j, k) + currGrid3D(V, i, j, k)) * 0.5f * (currGrid3D(U, i + 1, j, k) + currGrid3D(U, i + 1, j - 1, k))
//                - 0.5f * (currGrid3D(V, i, j, k) + currGrid3D(V, i - 1, j, k)) * 0.5f * (currGrid3D(U, i, j - 1, k) + currGrid3D(U, i, j, k))) // -dvu/dx 

//                - 1.0f / gridSizeJ * (powf(0.5f * (currGrid3D(V, i, j + 1, k) + currGrid3D(V, i, j, k)), 2) - powf(0.5f * (currGrid3D(V, i, j, k) + currGrid3D(V, i, j - 1, k)), 2)) // -dvv/dy

//                - 1.0f / (currGrid3D(RO, i, j, k) * gridSizeK(k)) * (
//                0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * 0.5f * (currGrid3D(W, i, j, k + 1) + currGrid3D(W, i, j - 1, k + 1)) * 0.5f * (currGrid3D(V, i, j, k + 1) + currGrid3D(V, i, j, k))
//                - 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * 0.5f * (currGrid3D(W, i, j, k) + currGrid3D(W, i, j - 1, k)) * 0.5f * (currGrid3D(V, i, j, k - 1) + currGrid3D(V, i, j, k))) // -dpvw/dz
//                - 1.0f / gridSizeJ * (cpd * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k)) * (currGrid3D(Pi, i, j, k) - currGrid3D(Pi, i, j - 1, k))) // -cpd*T*dP/dx
//                + Kx / powf(gridSizeI, 2) * (prevGrid3D(V, i + 1, j, k) - 2.0f * prevGrid3D(V, i, j, k) + prevGrid3D(V, i - 1, j, k))
//                + Ky / powf(gridSizeJ, 2) * (prevGrid3D(V, i, j + 1, k) - 2.0f * prevGrid3D(V, i, j, k) + prevGrid3D(V, i, j - 1, k))
//                + Kz / powf(gridSizeK(k), 2) * ((prevGrid3D(V, i, j, k + 1) - gridInit(V, i, j, k + 1)) - 2.0f * (prevGrid3D(V, i, j, k) - gridInit(V, i, j, k)) + (prevGrid3D(V, i, j, k - 1) - gridInit(V, i, j, k - 1))); // Diffusion (implicit)

//                //MAXED OUT INSTRUCTIONS
//                //gridRslow(W, i, j, k) =
//                //-1.0f / gridSizeI * (
//                //0.5f * (currGrid3D(U, i + 1, j, k) + currGrid3D(U, i + 1, j, k - 1)) * 0.5f * (currGrid3D(W, i + 1, j, k) + currGrid3D(W, i, j, k))
//                //- 0.5f * (currGrid3D(U, i, j, k) + currGrid3D(U, i, j, k - 1)) * 0.5f * (currGrid3D(W, i, j, k) + currGrid3D(W, i - 1, j, k))) // -duw/dx

//                //- 1.0f / gridSizeJ * (
//                //0.5f * (currGrid3D(V, i, j + 1, k) + currGrid3D(V, i, j + 1, k - 1)) * 0.5f * (currGrid3D(W, i, j + 1, k) + currGrid3D(W, i, j, k))
//                //- 0.5f * (currGrid3D(V, i, j, k) + currGrid3D(V, i, j, k - 1)) * 0.5f * (currGrid3D(W, i, j, k) + currGrid3D(W, i, j - 1, k))) // -duw/dx

//                //- 1.0f / (0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * 0.5f * (gridSizeK(k) + gridSizeK(km1))) *
//                //(currGrid3D(RO, i, j, k) * powf(0.5f * (currGrid3D(W, i, j, k + 1) + currGrid3D(W, i, j, k)), 2) - currGrid3D(RO, i, j, k - 1) * powf(0.5f * (currGrid3D(W, i, j, k) + currGrid3D(W, i, j, k - 1)), 2)) // -dpww/dz
//                //- 1.0f / (0.5f * (gridSizeK(k) + gridSizeK(km1))) *
//                //(cpd * 0.5f * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k) + gridInit(THETA, i, j, k - 1) + 0.61f * gridInit(QV, i, j, k - 1))
//                //* (currGrid3D(Pi, i, j, k) - currGrid3D(Pi, i, j, k - 1))) // -cpd* T*dP/dz
//                //+ g * 0.5f * (currGrid3D(THETA, i, j, k) / gridInit(THETA, i, j, k) + currGrid3D(THETA, i, j, k - 1) / gridInit(THETA, i, j, k - 1)
//                //+ 0.61f * (currGrid3D(QV, i, j, k) + currGrid3D(QV, i, j, k - 1)) - (currGrid3D(QC, i, j, k) + currGrid3D(QC, i, j, k - 1) + currGrid3D(QR, i, j, k) + currGrid3D(QR, i, j, k - 1))) // B=g* T'/T
//                //+ Kx / powf(gridSizeI, 2) * (prevGrid3D(W, i + 1, j, k) - 2.0f * prevGrid3D(W, i, j, k) + prevGrid3D(W, i - 1, j, k)) // Diffusion (implicit)
//                //+ Ky / powf(gridSizeJ, 2) * (prevGrid3D(W, i, j + 1, k) - 2.0f * prevGrid3D(W, i, j, k) + prevGrid3D(W, i, j - 1, k)) // Diffusion (implicit)
//                //+ Kz / powf(gridSizeK(k), 2) * (prevGrid3D(W, i, j, k + 1) - 2.0f * prevGrid3D(W, i, j, k) + prevGrid3D(W, i, j, k - 1)); // d2w/dx2+d2w/dz2

//                //MAXED OUT INSTRUCTIONS
//                //gridRslow(THETA, i, j, k) =
//                //-1.0f / gridSizeI * (currGrid3D(U, i + 1, j, k) * 0.5f * (currGrid3D(THETA, i + 1, j, k) + currGrid3D(THETA, i, j, k))
//                //- currGrid3D(U, i, j, k) * 0.5f * (currGrid3D(THETA, i, j, k) + currGrid3D(THETA, i - 1, j, k))) // -duT/dx

//                //- 1.0f / gridSizeJ * (currGrid3D(V, i, j + 1, k) * 0.5f * (currGrid3D(THETA, i, j + 1, k) + currGrid3D(THETA, i, j, k))
//                //- currGrid3D(V, i, j, k) * 0.5f * (currGrid3D(THETA, i, j, k) + currGrid3D(THETA, i, j - 1, k))) // -dvT/dx NN

//                //- 1.0f / (currGrid3D(RO, i, j, k) * gridSizeK(k)) * (
//                //0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * 0.5f * (currGrid3D(THETA, i, j, k + 1) + currGrid3D(THETA, i, j, k))
//                //- 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * 0.5f * (currGrid3D(THETA, i, j, k) + currGrid3D(THETA, i, j, k - 1))) // -dpwT/dz
//                //- 1.0f / (currGrid3D(RO, i, j, k)) * 0.5f * (
//                //0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * (gridInit(THETA, i, j, k + 1) - gridInit(THETA, i, j, k)) / gridSizeK(k + 1)
//                //+ 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * (gridInit(THETA, i, j, k) - gridInit(THETA, i, j, k - 1)) / gridSizeK(k)) // -w/p*dpT/dz (mean state)
//                //+ Kx / powf(gridSizeI, 2) * (prevGrid3D(THETA, i + 1, j, k) - 2.0f * prevGrid3D(THETA, i, j, k) + prevGrid3D(THETA, i - 1, j, k)) // Diffusion (implicit)
//                //+ Ky / powf(gridSizeJ, 2) * (prevGrid3D(THETA, i, j + 1, k) - 2.0f * prevGrid3D(THETA, i, j, k) + prevGrid3D(THETA, i, j - 1, k)) // Diffusion (implicit)
//                //+ Kz / powf(gridSizeK(k), 2) * (prevGrid3D(THETA, i, j, k + 1) - 2.0f * prevGrid3D(THETA, i, j, k) + prevGrid3D(THETA, i, j, k - 1)); // d2T/dx2+d2T/dz2

//                gridRslow(Pi, i, j, k) =
//                -1.0f * (powf(cmax, 2) / (currGrid3D(RO, i, j, k) * cpd * powf(gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k), 2))) * ( // multiplier -cs^2/(cpd* p*T^2)
//                +(currGrid3D(RO, i, j, k) * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k)) * (currGrid3D(U, i + 1, j, k) - currGrid3D(U, i, j, k))) / gridSizeI // pTdu/dx

//                + (currGrid3D(RO, i, j, k) * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k)) * (currGrid3D(V, i, j + 1, k) - currGrid3D(V, i, j, k))) / gridSizeJ // pTdv/dx

//                + (0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * 0.5f * (gridInit(THETA, i, j, k + 1) + gridInit(THETA, i, j, k))
//                - 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * 0.5f * (gridInit(THETA, i, j, k) + gridInit(THETA, i, j, k - 1))) / gridSizeK(k) // pTdw/dz
//                )
//                + Kx / powf(gridSizeI, 2) * (prevGrid3D(Pi, i + 1, j, k) - 2.0f * prevGrid3D(Pi, i, j, k) + prevGrid3D(Pi, i - 1, j, k)) // Diffusion (implicit)
//                + Ky / powf(gridSizeI, 2) * (prevGrid3D(Pi, i, j + 1, k) - 2.0f * prevGrid3D(Pi, i, j, k) + prevGrid3D(Pi, i, j - 1, k)) // Diffusion (implicit)
//                + Kz / powf(gridSizeK(k), 2) * (prevGrid3D(Pi, i, j, k + 1) - 2.0f * prevGrid3D(Pi, i, j, k) + prevGrid3D(Pi, i, j, k - 1)); // d2P/dx2+d2P/dz2

//                //MAXED OUT INSTRUCTIONS
//                //// Moisture terms
//                //gridRslow(QV, i, j, k) =
//                //-1.0f / gridSizeI * (currGrid3D(U, i + 1, j, k) * 0.5f * (currGrid3D(QV, i + 1, j, k) + currGrid3D(QV, i, j, k))
//                //- currGrid3D(U, i, j, k) * 0.5f * (currGrid3D(QV, i, j, k) + currGrid3D(QV, i - 1, j, k))) // -duqv/dx

//                //- 1.0f / gridSizeJ * (currGrid3D(V, i, j + 1, k) * 0.5f * (currGrid3D(QV, i, j + 1, k) + currGrid3D(QV, i, j, k))
//                //- currGrid3D(V, i, j, k) * 0.5f * (currGrid3D(QV, i, j, k) + currGrid3D(QV, i, j - 1, k))) // -dvqv/dy

//                //- 1.0f / (currGrid3D(RO, i, j, k) * gridSizeK(k)) * (
//                //0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * 0.5f * (currGrid3D(QV, i, j, k + 1) + currGrid3D(QV, i, j, k))
//                //- 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * 0.5f * (currGrid3D(QV, i, j, k) + currGrid3D(QV, i, j, k - 1))) // -dpwqv/dz
//                //- 1.0f / (currGrid3D(RO, i, j, k)) * 0.5f * (
//                //0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * (gridInit(QV, i, j, k + 1) - gridInit(QV, i, j, k)) / gridSizeK(k + 1)
//                //+ 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * (gridInit(QV, i, j, k) - gridInit(QV, i, j, k - 1)) / gridSizeK(k)) // -w/p*dpqv/dz (mean state)
//                //+ Kx / powf(gridSizeI, 2) * (prevGrid3D(QV, i + 1, j, k) - 2.0f * prevGrid3D(QV, i, j, k) + prevGrid3D(QV, i - 1, j, k)) // Diffusion (implicit)
//                //+ Ky / powf(gridSizeI, 2) * (prevGrid3D(QV, i, j + 1, k) - 2.0f * prevGrid3D(QV, i, j, k) + prevGrid3D(QV, i, j - 1, k)) // Diffusion (implicit)
//                //+ Kz / powf(gridSizeK(k), 2) * (prevGrid3D(QV, i, j, k + 1) - 2.0f * prevGrid3D(QV, i, j, k) + prevGrid3D(QV, i, j, k - 1)); // d2q/dx2+d2q/dz2

                
//                gridRslow(QC, i, j, k) =
//                -1.0f / gridSizeI * (currGrid3D(U, i + 1, j, k) * 0.5f * (currGrid3D(QC, i + 1, j, k) + currGrid3D(QC, i, j, k))
//                - currGrid3D(U, i, j, k) * 0.5f * (currGrid3D(QC, i, j, k) + currGrid3D(QC, i - 1, j, k))) // -duqv/dx

//                - 1.0f / gridSizeJ * (currGrid3D(V, i, j + 1, k) * 0.5f * (currGrid3D(QC, i, j + 1, k) + currGrid3D(QC, i, j, k))
//                - currGrid3D(V, i, j, k) * 0.5f * (currGrid3D(QC, i, j, k) + currGrid3D(QC, i, j - 1, k))) // -duqv/dx

//                - 1.0f / (currGrid3D(RO, i, j, k) * gridSizeK(k)) * (
//                0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * 0.5f * (currGrid3D(QC, i, j, k + 1) + currGrid3D(QC, i, j, k))
//                - 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * 0.5f * (currGrid3D(QC, i, j, k) + currGrid3D(QC, i, j, k - 1))) // -dpwqv/dz
//                + Kx / powf(gridSizeI, 2) * (prevGrid3D(QC, i + 1, j, k) - 2.0f * prevGrid3D(QC, i, j, k) + prevGrid3D(QC, i - 1, j, k)) // Diffusion (implicit)
//                + Ky / powf(gridSizeI, 2) * (prevGrid3D(QC, i, j + 1, k) - 2.0f * prevGrid3D(QC, i, j, k) + prevGrid3D(QC, i, j - 1, k)) // Diffusion (implicit)
//                + Kz / powf(gridSizeK(k), 2) * (prevGrid3D(QC, i, j, k + 1) - 2.0f * prevGrid3D(QC, i, j, k) + prevGrid3D(QC, i, j, k - 1)); // d2q/dx2+d2q/dz2

//                //MAXED OUT INSTRUCTIONS
//                //gridRslow(QR, i, j, k) =
//                //-1.0f / gridSizeI * (currGrid3D(U, i + 1, j, k) * 0.5f * (currGrid3D(QR, i + 1, j, k) + currGrid3D(QR, i, j, k))
//                //- currGrid3D(U, i, j, k) * 0.5f * (currGrid3D(QR, i, j, k) + currGrid3D(QR, i - 1, j, k))) // -duqv/dx

//                //- 1.0f / gridSizeJ * (currGrid3D(V, i, j + 1, k) * 0.5f * (currGrid3D(QR, i, j + 1, k) + currGrid3D(QR, i, j, k))
//                //- currGrid3D(V, i, j, k) * 0.5f * (currGrid3D(QR, i, j, k) + currGrid3D(QR, i, j - 1, k))) // -dvqv/dy

//                //- 1.0f / (currGrid3D(RO, i, j, k) * gridSizeK(k)) * (
//                //0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * 0.5f * (currGrid3D(QR, i, j, k + 1) + currGrid3D(QR, i, j, k))
//                //- 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * 0.5f * (currGrid3D(QR, i, j, k) + currGrid3D(QR, i, j, k - 1))) // -dpwqv/dz
//                //+ Kx / powf(gridSizeI, 2) * (prevGrid3D(QR, i + 1, j, k) - 2.0f * prevGrid3D(QR, i, j, k) + prevGrid3D(QR, i - 1, j, k)) // Diffusion (implicit)
//                //+ Ky / powf(gridSizeI, 2) * (prevGrid3D(QR, i, j + 1, k) - 2.0f * prevGrid3D(QR, i, j, k) + prevGrid3D(QR, i, j - 1, k)) // Diffusion (implicit)
//                //+ Kz / powf(gridSizeK(k), 2) * (prevGrid3D(QR, i, j, k + 1) - 2.0f * prevGrid3D(QR, i, j, k) + prevGrid3D(QR, i, j, k - 1)); // d2q/dx2+d2q/dz2

//                //gridRslow(RO, i, j, k) = 0.0f;
//                gridRslow(RO, i, j, k) = 1.2f / gridSizeI / gridSizeJ;
//            }
//        }
//    }
//}

///* STEP 1 Fundamental Equations */
//void simulateSTEP1a()
//{

//    [loop]
//    for (int k = 0; k < gridZ - 1; k++)
//    {
//        int km1 = k - 1;
//        if (km1 < 0)
//        {
//            km1 = 0;
//        }
//        [loop]
//        for (int j = 0; j < gridY; j++)
//        {
//            [loop]
//            for (int i = 0; i < gridX; i++)
//            {
//                //gridRslow(W, i, j, k) =
//                //-1.0f / gridSizeI * (
//                //0.5f * (currGrid3D(U, i + 1, j, k) + currGrid3D(U, i + 1, j, k - 1)) * 0.5f * (currGrid3D(W, i + 1, j, k) + currGrid3D(W, i, j, k))
//                //- 0.5f * (currGrid3D(U, i, j, k) + currGrid3D(U, i, j, k - 1)) * 0.5f * (currGrid3D(W, i, j, k) + currGrid3D(W, i - 1, j, k))) // -duw/dx

//                //- 1.0f / gridSizeJ * (
//                //0.5f * (currGrid3D(V, i, j + 1, k) + currGrid3D(V, i, j + 1, k - 1)) * 0.5f * (currGrid3D(W, i, j + 1, k) + currGrid3D(W, i, j, k))
//                //- 0.5f * (currGrid3D(V, i, j, k) + currGrid3D(V, i, j, k - 1)) * 0.5f * (currGrid3D(W, i, j, k) + currGrid3D(W, i, j - 1, k))) // -duw/dx

//                //- 1.0f / (0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * 0.5f * (gridSizeK(k) + gridSizeK(km1))) *
//                //(currGrid3D(RO, i, j, k) * powf(0.5f * (currGrid3D(W, i, j, k + 1) + currGrid3D(W, i, j, k)), 2) - currGrid3D(RO, i, j, k - 1) * powf(0.5f * (currGrid3D(W, i, j, k) + currGrid3D(W, i, j, k - 1)), 2)) // -dpww/dz
//                //- 1.0f / (0.5f * (gridSizeK(k) + gridSizeK(km1))) *
//                //(cpd * 0.5f * (gridInit(THETA, i, j, k) + 0.61f * gridInit(QV, i, j, k) + gridInit(THETA, i, j, k - 1) + 0.61f * gridInit(QV, i, j, k - 1))
//                //* (currGrid3D(Pi, i, j, k) - currGrid3D(Pi, i, j, k - 1))) // -cpd* T*dP/dz
//                //+ g * 0.5f * (currGrid3D(THETA, i, j, k) / gridInit(THETA, i, j, k) + currGrid3D(THETA, i, j, k - 1) / gridInit(THETA, i, j, k - 1)
//                //+ 0.61f * (currGrid3D(QV, i, j, k) + currGrid3D(QV, i, j, k - 1)) - (currGrid3D(QC, i, j, k) + currGrid3D(QC, i, j, k - 1) + currGrid3D(QR, i, j, k) + currGrid3D(QR, i, j, k - 1))) // B=g* T'/T
//                //+ Kx / powf(gridSizeI, 2) * (prevGrid3D(W, i + 1, j, k) - 2.0f * prevGrid3D(W, i, j, k) + prevGrid3D(W, i - 1, j, k)) // Diffusion (implicit)
//                //+ Ky / powf(gridSizeJ, 2) * (prevGrid3D(W, i, j + 1, k) - 2.0f * prevGrid3D(W, i, j, k) + prevGrid3D(W, i, j - 1, k)) // Diffusion (implicit)
//                //+ Kz / powf(gridSizeK(k), 2) * (prevGrid3D(W, i, j, k + 1) - 2.0f * prevGrid3D(W, i, j, k) + prevGrid3D(W, i, j, k - 1)); // d2w/dx2+d2w/dz2





//                 gridRslow(QR, i, j, k) =
//                -1.0f / gridSizeI * (currGrid3D(U, i + 1, j, k) * 0.5f * (currGrid3D(QR, i + 1, j, k) + currGrid3D(QR, i, j, k))
//                - currGrid3D(U, i, j, k) * 0.5f * (currGrid3D(QR, i, j, k) + currGrid3D(QR, i - 1, j, k))) // -duqv/dx

//                - 1.0f / gridSizeJ * (currGrid3D(V, i, j + 1, k) * 0.5f * (currGrid3D(QR, i, j + 1, k) + currGrid3D(QR, i, j, k))
//                - currGrid3D(V, i, j, k) * 0.5f * (currGrid3D(QR, i, j, k) + currGrid3D(QR, i, j - 1, k))) // -dvqv/dy

//                - 1.0f / (currGrid3D(RO, i, j, k) * gridSizeK(k)) * (
//                0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * 0.5f * (currGrid3D(QR, i, j, k + 1) + currGrid3D(QR, i, j, k))
//                - 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * 0.5f * (currGrid3D(QR, i, j, k) + currGrid3D(QR, i, j, k - 1))) // -dpwqv/dz
//                + Kx / powf(gridSizeI, 2) * (prevGrid3D(QR, i + 1, j, k) - 2.0f * prevGrid3D(QR, i, j, k) + prevGrid3D(QR, i - 1, j, k)) // Diffusion (implicit)
//                + Ky / powf(gridSizeI, 2) * (prevGrid3D(QR, i, j + 1, k) - 2.0f * prevGrid3D(QR, i, j, k) + prevGrid3D(QR, i, j - 1, k)) // Diffusion (implicit)
//                + Kz / powf(gridSizeK(k), 2) * (prevGrid3D(QR, i, j, k + 1) - 2.0f * prevGrid3D(QR, i, j, k) + prevGrid3D(QR, i, j, k - 1)); // d2q/dx2+d2q/dz2

//            }
//        }
//    }
//}


///* STEP 1 Fundamental Equations */
//void simulateSTEP1b()
//{

//    [loop]
//    for (int k = 0; k < gridZ - 1; k++)
//    {
//        int km1 = k - 1;
//        if (km1 < 0)
//        {
//            km1 = 0;
//        }
//        [loop]
//        for (int j = 0; j < gridY; j++)
//        {
//            [loop]
//            for (int i = 0; i < gridX; i++)
//            {
//                // gridRslow(THETA, i, j, k) =
//                //-1.0f / gridSizeI * (currGrid3D(U, i + 1, j, k) * 0.5f * (currGrid3D(THETA, i + 1, j, k) + currGrid3D(THETA, i, j, k))
//                //- currGrid3D(U, i, j, k) * 0.5f * (currGrid3D(THETA, i, j, k) + currGrid3D(THETA, i - 1, j, k))) // -duT/dx

//                //- 1.0f / gridSizeJ * (currGrid3D(V, i, j + 1, k) * 0.5f * (currGrid3D(THETA, i, j + 1, k) + currGrid3D(THETA, i, j, k))
//                //- currGrid3D(V, i, j, k) * 0.5f * (currGrid3D(THETA, i, j, k) + currGrid3D(THETA, i, j - 1, k))) // -dvT/dx NN

//                //- 1.0f / (currGrid3D(RO, i, j, k) * gridSizeK(k)) * (
//                //0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * 0.5f * (currGrid3D(THETA, i, j, k + 1) + currGrid3D(THETA, i, j, k))
//                //- 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * 0.5f * (currGrid3D(THETA, i, j, k) + currGrid3D(THETA, i, j, k - 1))) // -dpwT/dz
//                //- 1.0f / (currGrid3D(RO, i, j, k)) * 0.5f * (
//                //0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * (gridInit(THETA, i, j, k + 1) - gridInit(THETA, i, j, k)) / gridSizeK(k + 1)
//                //+ 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * (gridInit(THETA, i, j, k) - gridInit(THETA, i, j, k - 1)) / gridSizeK(k)) // -w/p*dpT/dz (mean state)
//                //+ Kx / powf(gridSizeI, 2) * (prevGrid3D(THETA, i + 1, j, k) - 2.0f * prevGrid3D(THETA, i, j, k) + prevGrid3D(THETA, i - 1, j, k)) // Diffusion (implicit)
//                //+ Ky / powf(gridSizeJ, 2) * (prevGrid3D(THETA, i, j + 1, k) - 2.0f * prevGrid3D(THETA, i, j, k) + prevGrid3D(THETA, i, j - 1, k)) // Diffusion (implicit)
//                //+ Kz / powf(gridSizeK(k), 2) * (prevGrid3D(THETA, i, j, k + 1) - 2.0f * prevGrid3D(THETA, i, j, k) + prevGrid3D(THETA, i, j, k - 1)); // d2T/dx2+d2T/dz2


//                //MAXED OUT INSTRUCTIONS
//                // Moisture terms
//                //gridRslow(QV, i, j, k) =
//                //-1.0f / gridSizeI * (currGrid3D(U, i + 1, j, k) * 0.5f * (currGrid3D(QV, i + 1, j, k) + currGrid3D(QV, i, j, k))
//                //- currGrid3D(U, i, j, k) * 0.5f * (currGrid3D(QV, i, j, k) + currGrid3D(QV, i - 1, j, k))) // -duqv/dx

//                //- 1.0f / gridSizeJ * (currGrid3D(V, i, j + 1, k) * 0.5f * (currGrid3D(QV, i, j + 1, k) + currGrid3D(QV, i, j, k))
//                //- currGrid3D(V, i, j, k) * 0.5f * (currGrid3D(QV, i, j, k) + currGrid3D(QV, i, j - 1, k))) // -dvqv/dy

//                //- 1.0f / (currGrid3D(RO, i, j, k) * gridSizeK(k)) * (
//                //0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * 0.5f * (currGrid3D(QV, i, j, k + 1) + currGrid3D(QV, i, j, k))
//                //- 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * 0.5f * (currGrid3D(QV, i, j, k) + currGrid3D(QV, i, j, k - 1))) // -dpwqv/dz
//                //- 1.0f / (currGrid3D(RO, i, j, k)) * 0.5f * (
//                //0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * currGrid3D(W, i, j, k + 1) * (gridInit(QV, i, j, k + 1) - gridInit(QV, i, j, k)) / gridSizeK(k + 1)
//                //+ 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * currGrid3D(W, i, j, k) * (gridInit(QV, i, j, k) - gridInit(QV, i, j, k - 1)) / gridSizeK(k)) // -w/p*dpqv/dz (mean state)
//                //+ Kx / powf(gridSizeI, 2) * (prevGrid3D(QV, i + 1, j, k) - 2.0f * prevGrid3D(QV, i, j, k) + prevGrid3D(QV, i - 1, j, k)) // Diffusion (implicit)
//                //+ Ky / powf(gridSizeI, 2) * (prevGrid3D(QV, i, j + 1, k) - 2.0f * prevGrid3D(QV, i, j, k) + prevGrid3D(QV, i, j - 1, k)) // Diffusion (implicit)
//                //+ Kz / powf(gridSizeK(k), 2) * (prevGrid3D(QV, i, j, k + 1) - 2.0f * prevGrid3D(QV, i, j, k) + prevGrid3D(QV, i, j, k - 1)); // d2q/dx2+d2q/dz2
//            }
//        }
//    }
//}

///* STEP2: Kelsner Microphysics */
//void simulateSTEP2()
//{

//    [loop]
//    for (int k = 1; k < gridZ - 1; k++)
//    {
//        [loop]
//        for (int j = 0; j < gridY; j++)
//        {
//            [loop]
//            for (int i = 0; i < gridX; i++)
//            {

//        // Kessler microphysics.
//        // A = max[ k1 * (qc-qc0) , 0 ] : autoconverstion qc -> qr
//        // B = k2 * qc * qr^7/8	: accretion qc -> qr
//        // C: condensation ; qv <-> qv
//        // E: evaporation ; qr -> qv
//        // All values from t-1 step
//        // Order of calculation matters here

//                float A_conv = 0.0;
//                if (prevGrid3D(QC, i, j, k) > 0.001)
//                    A_conv = max(0.0f, 0.001 * (prevGrid3D(QC, i, j, k) - 0.001)); // conversion cloud -> rain

//                float B_acc = max(0.0f, gridInit(RO, i, j, k) * 2.2f * prevGrid3D(QC, i, j, k) * powf(prevGrid3D(QR, i, j, k), 0.875f)); // accretion cloud -> rain

//                A_conv *= rainProbability;
//                B_acc *= rainProbability;

//        // Saturation adjustment (Soong & Ogura)
//                float pmean = powf(gridInit(Pi, i, j, k), cpd / Rd) * p_0; // Mean pressure
//                float qvs = (380.0f / pmean) * exp(7.5f * log(10.0f) *
//          ((prevGrid3D(THETA, i, j, k) + gridInit(THETA, i, j, k)) * ((prevGrid3D(Pi, i, j, k) + gridInit(Pi, i, j, k))) - 273.0f) /
//          ((prevGrid3D(THETA, i, j, k) + gridInit(THETA, i, j, k)) * ((prevGrid3D(Pi, i, j, k) + gridInit(Pi, i, j, k))) - 36.0f)); // Saturation mixing ratio
//                prevGrid3D(QV, i, j, k) = max(prevGrid3D(QV, i, j, k), -1.0f * gridInit(QV, i, j, k)); // remove negative values
//                float rsub = qvs * (7.5f * logf(10.0f) * (273.0f - 36.0f) * Llv / cpd) /
//          powf(gridInit(Pi, i, j, k) * (prevGrid3D(THETA, i, j, k) + gridInit(THETA, i, j, k)), 2);

//                float Cond = min(prevGrid3D(QV, i, j, k) + gridInit(QV, i, j, k),
//          max(0.0f, ((prevGrid3D(QV, i, j, k) + gridInit(QV, i, j, k)) - qvs) / (1.0f + rsub))); // Condensation (qv -> qc)

//                float Cvent = 1.6f + 124.9f * powf(gridInit(RO, i, j, k) * prevGrid3D(QC, i, j, k), 0.2046f); // ventillation factor
//                float Evap = min(min(prevGrid3D(QR, i, j, k), max(-1.0f * Cond - prevGrid3D(QC, i, j, k), 0.0f)), // 3 options
//                dT * Cvent * powf(gridInit(RO, i, j, k) * prevGrid3D(QR, i, j, k), 0.525f) / (5.4e5 + 2.55e8 / (pmean * qvs))
//          * max(qvs - prevGrid3D(QV, i, j, k), 0.0f) / (gridInit(RO, i, j, k) * qvs));
//                Cond = max(Cond, -1.0f * prevGrid3D(QC, i, j, k));

//                gridRslow(QV, i, j, k) = gridRslow(QV, i, j, k) - Cond + Evap; // Net mass conversion

//                gridRslow(QC, i, j, k) = gridRslow(QC, i, j, k) + Cond - A_conv - B_acc; // Net mass conversion

//                float vterm0 = 36.34f * sqrtf(gridInit(RO, i, j, 0) / gridInit(RO, i, j, k)) * powf(max(gridInit(RO, i, j, k) * prevGrid3D(QR, i, j, k), 0.0f), 0.1364f);
//                float vterm1 = 36.34f * sqrtf(gridInit(RO, i, j, 0) / gridInit(RO, i, j, k + 1)) * powf(max(gridInit(RO, i, j, k + 1) * prevGrid3D(QR, i, j, k + 1), 0.0f), 0.1364f); // vT terminal velocity
//        // note, it's possible that vT > CFL.

//                gridRslow(QR, i, j, k) = gridRslow(QR, i, j, k) + A_conv + B_acc - Evap // Net mass change
//          + 1.0f / (currGrid3D(RO, i, j, k) * gridSizeK(k)) * (
//          0.5f * (currGrid3D(RO, i, j, k + 1) + currGrid3D(RO, i, j, k)) * vterm1 * 0.5f * (prevGrid3D(QR, i, j, k + 1) + prevGrid3D(QR, i, j, k))
//          - 0.5f * (currGrid3D(RO, i, j, k) + currGrid3D(RO, i, j, k - 1)) * vterm0 * 0.5f * (prevGrid3D(QR, i, j, k) + prevGrid3D(QR, i, j, k - 1))); // Falling rain

//                gridRslow(THETA, i, j, k) = gridRslow(THETA, i, j, k) + Llv / (cpd * gridInit(Pi, i, j, k)) * (Cond - Evap); // latent heating Lv/(cpd * P) * (C-E);
//            }
//        }
//    }
//}

///* STEP3: Move forward in time */
//void simulateSTEP3()
//{

//    [loop]
//    for (int k = 1; k < gridZ - 1; k++)
//    {
//        [loop]
//        for (int j = 0; j < gridY; j++)
//        {
//            [loop]
//            for (int i = 0; i < gridX; i++)
//            {

//                if (simulationTime == 0.0f)
//                { // 1st step: forward in time
//          //	printf("first Iteration\n");
//                    nextGrid3D(U, i, j, k) = currGrid3D(U, i, j, k) + dT * gridRslow(U, i, j, k);
//                    nextGrid3D(V, i, j, k) = currGrid3D(V, i, j, k) + dT * gridRslow(V, i, j, k);
//                    nextGrid3D(W, i, j, k) = currGrid3D(W, i, j, k) + dT * gridRslow(W, i, j, k);
//                    if ((k < 2))
//                        nextGrid3D(W, i, j, k) = 0.0f; // top & bottom BCs //|| (k==zEnd)
//                    nextGrid3D(Pi, i, j, k) = currGrid3D(Pi, i, j, k) + dT * gridRslow(Pi, i, j, k);
//                    nextGrid3D(THETA, i, j, k) = currGrid3D(THETA, i, j, k) + dT * gridRslow(THETA, i, j, k);
//                    nextGrid3D(QV, i, j, k) = currGrid3D(QV, i, j, k) + dT * gridRslow(QV, i, j, k);
//                    nextGrid3D(QC, i, j, k) = currGrid3D(QC, i, j, k) + dT * gridRslow(QC, i, j, k);
//                    nextGrid3D(QR, i, j, k) = currGrid3D(QR, i, j, k) + dT * gridRslow(QR, i, j, k);
//                    nextGrid3D(RO, i, j, k) = currGrid3D(RO, i, j, k) + dT * gridRslow(RO, i, j, k);

//                }
//                else
//                { // subsequent steps: leapfrog

//          //	printf("No first Iteration\n");
//                    nextGrid3D(U, i, j, k) = prevGrid3D(U, i, j, k) + 2.0f * dT * gridRslow(U, i, j, k);
//                    nextGrid3D(V, i, j, k) = prevGrid3D(V, i, j, k) + 2.0f * dT * gridRslow(V, i, j, k);
//                    nextGrid3D(W, i, j, k) = prevGrid3D(W, i, j, k) + 2.0f * dT * gridRslow(W, i, j, k);
//                    if ((k < 2))
//                        nextGrid3D(W, i, j, k) = 0.0f; // top & bottom BCs // || (k==zEnd)
//                    nextGrid3D(Pi, i, j, k) = prevGrid3D(Pi, i, j, k) + 2.0f * dT * gridRslow(Pi, i, j, k);
//                    nextGrid3D(THETA, i, j, k) = prevGrid3D(THETA, i, j, k) + 2.0f * dT * gridRslow(THETA, i, j, k);
//                    nextGrid3D(QV, i, j, k) = prevGrid3D(QV, i, j, k) + 2.0f * dT * gridRslow(QV, i, j, k);
//                    nextGrid3D(QC, i, j, k) = prevGrid3D(QC, i, j, k) + 2.0f * dT * gridRslow(QC, i, j, k);
//                    nextGrid3D(QR, i, j, k) = prevGrid3D(QR, i, j, k) + 2.0f * dT * gridRslow(QR, i, j, k);
//                    nextGrid3D(RO, i, j, k) = prevGrid3D(RO, i, j, k) + 2.0f * dT * gridRslow(RO, i, j, k);

//          // Roberts-Asselin filter
//                    currGrid3D(U, i, j, k) = currGrid3D(U, i, j, k) + 0.1f * (nextGrid3D(U, i, j, k) - 2.0f * currGrid3D(U, i, j, k) + prevGrid3D(U, i, j, k));
//                    currGrid3D(V, i, j, k) = currGrid3D(V, i, j, k) + 0.1f * (nextGrid3D(V, i, j, k) - 2.0f * currGrid3D(V, i, j, k) + prevGrid3D(V, i, j, k));
//                    currGrid3D(W, i, j, k) = currGrid3D(W, i, j, k) + 0.1f * (nextGrid3D(W, i, j, k) - 2.0f * currGrid3D(W, i, j, k) + prevGrid3D(W, i, j, k));
//                    currGrid3D(THETA, i, j, k) = currGrid3D(THETA, i, j, k) + 0.1f * (nextGrid3D(THETA, i, j, k) - 2.0f * currGrid3D(THETA, i, j, k) + prevGrid3D(THETA, i, j, k));
//                    currGrid3D(Pi, i, j, k) = currGrid3D(Pi, i, j, k) + 0.1f * (nextGrid3D(Pi, i, j, k) - 2.0f * currGrid3D(Pi, i, j, k) + prevGrid3D(Pi, i, j, k));
//                    currGrid3D(QV, i, j, k) = currGrid3D(QV, i, j, k) + 0.1f * (nextGrid3D(QV, i, j, k) - 2.0f * currGrid3D(QV, i, j, k) + prevGrid3D(QV, i, j, k));
//                    currGrid3D(QC, i, j, k) = currGrid3D(QC, i, j, k) + 0.1f * (nextGrid3D(QC, i, j, k) - 2.0f * currGrid3D(QC, i, j, k) + prevGrid3D(QC, i, j, k));
//                    currGrid3D(QR, i, j, k) = currGrid3D(QR, i, j, k) + 0.1f * (nextGrid3D(QR, i, j, k) - 2.0f * currGrid3D(QR, i, j, k) + prevGrid3D(QR, i, j, k));
//                    currGrid3D(RO, i, j, k) = currGrid3D(RO, i, j, k) + 0.1f * (nextGrid3D(RO, i, j, k) - 2.0f * currGrid3D(RO, i, j, k) + prevGrid3D(RO, i, j, k));
//                }
//            }
//        }
//    }
//} // STEP 3

///* STEP4: Radiation model */
//void simulateSTEP4()
//{

//    [loop]
//    for (int j = 0; j < gridY; j++)
//    {
//        [loop]
//        for (int i = 0; i < gridX; i++)
//        {



//      ////////////////////////////////////////
//      // INIT VALUES
//            if (simulationTime == 0.0f)
//            { // 1st step: forward in time 
//                currGrid3D(THETA, i, j, 0) = 0;

//                ground(GR_TG, i, j) = 23.5f + 273.15f;
//                ground(GR_TA, i, j) = gridInit(THETA, i, j, 0);

//                ground(GR_TG_RESET, i, j) = FLT_MAX; // INF

//                ground(GR_TG_CORR, i, j) = 0.0f;
//                ground(GR_TA_CORR, i, j) = 0.0f;

//                ground(GR_CLOUD_COVER, i, j) = 0.0f;
//            }

//      ////////////////////////////////////////
//      // CLOUD COVERAGE

//            if ((int(simulationTime / dT) % (60 * 5)) == 0)
//            { // each 300 steps
//                float cloudTotal = 0.0f;
//                [loop]
//                for (int z = (0.33f * gridZ);
//                z < (0.83f * gridZ);
//                z++)
//                {
//                    float density = nextGrid3D(QC, i, j, z);
//                    if (density == 0.0f)
//                        continue;
//                    if (density > 2e-3f)
//                    {
//                        density = 0.99f;
//                    }
//                    else
//                    {
//                        if (density < 1e-3f)
//                        {
//                            density = 0.0f;
//                        }
//                        else
//                        {
//                            density = -1520000.0f * (density * density) + 5360.00f * (density) - 3.74f;
//                        }
//                    }
//                    cloudTotal += density * 0.1f; //0.05f so it has soft borders
//                    if (cloudTotal >= 1.0f)
//                    {
//                        break; // not necessary to check more
//                    }
//                }
//                ground(GR_CLOUD_COVER, i, j) = fmin(cloudTotal, 1.0f);
//            }


//      // UTC
//            float t_UTC = initTimeUTC_hours + (simulationTime / 3600.0f); //day overflow
//            int advancedDays = int(t_UTC / (24.0f)); //full days
//            float dayInYearUTC = initDayInYearUTC + advancedDays;

//            while (dayInYearUTC > 365)
//                dayInYearUTC -= 365;
//            t_UTC -= advancedDays * 24.0f;

//    //  // LOCAL
//            float t_Local = t_UTC + timeZone;

//            if (t_Local < 0.0f)
//            {
//                t_Local += 24.0f;
//            }

//            if (t_Local > 24.0f)
//            {
//                t_Local -= 24.0f;
//            }


//            float lat = latitudeRad;
//            float longi = -longitudeRad; //note NEGATE (West)

//            float delta = 0.409f * cos((2.0f * M_PI) * (dayInYearUTC - 173.0f) / (365.25f)); //d_s: solarDeclineAngle
//            float sinPSI = sin(lat) * sin(delta) - cos(lat) * cos(delta) * cos(((M_PI * t_UTC) / 12.0f) - longi);

//            float gamma = 0.0000010717f * powf(t_Local, 5.0f) + 0.0000818369f * powf(t_Local, 4.0f) - 0.0060500842f * powf(t_Local, 3.0f) + 0.0772306397f * powf(t_Local, 2.0f) + 0.1444444444f * t_Local - 1.8441558442f;


//    //  // RADITATION

//            float alb = ground(GR_ALBEDO, i, j);
//            float c_g_a = ground(GR_CGA, i, j);

//            float sig_l = ground(GR_CLOUD_COVER, i, j);
//            float sig_m = ground(GR_CLOUD_COVER, i, j);


//            float I = 0.08f * (1.0f - 0.1f * sig_h - 0.3f * sig_m - 0.6f * sig_l);

//            float Tk = (0.6f + 0.2f * sinPSI) * (1.0f - 0.4f * sig_h) * (1.0f - 0.7f * sig_m) * (1.0f - 0.4f * sig_l); //trans
//            float Q_net = (1.0f - alb) * S_const * Tk * sinPSI + I;
//            if (sinPSI < 0)
//                Q_net = I;
//            float a_fr;
//            if (ground(GR_TG, i, j) > ground(GR_TA, i, j))
//            {
//        //DAY
//                a_fr = 3e-4f;
//            }
//            else
//            {
//        //NIGHT
//                a_fr = 1.1e-4f;
//            }

//            float T_G_t = ((-Q_net / c_g_a) + (2.0f * M_PI / dur * (T_M - ground(GR_TG, i, j))) - (a_fr * (ground(GR_TG, i, j) - ground(GR_TA, i, j))));
//            float Q_g = -1.0f * ((c_g_a * T_G_t) + (2.0f * M_PI * c_g_a / dur * (ground(GR_TG, i, j) - T_M))); //Units are fomd
//            float Q_h = (-Q_net + Q_g) / ground(GR_BETA_INV, i, j);

//            ground(GR_TG, i, j) += (dT * T_G_t) + ground(GR_TG_CORR, i, j); // NEW TG
//            ground(GR_TA, i, j) += (dT * Q_h * 1.0e-3f) + ground(GR_TA_CORR, i, j); // Introduced this new time parameterization //NEW TA

//      // STEP 0: Save ref value after 2 hours of simulation
//            if ((ground(GR_TG_RESET, i, j) == FLT_MAX) && (simulationTime >= 3600.0f * 2.0f))
//            { // put first FLT_MAX to avoid to comparisons
//                ground(GR_TG_RESET, i, j) = ground(GR_TG, i, j);
//                ground(GR_TA_RESET, i, j) = ground(GR_TA, i, j);
//            }

//      // STEP1: Update Correction after Each 24hours (+2h)
//            if ((simulationTime >= 3600.0f * (2.0f + 24.0f)) && ((int(simulationTime) - 2 * 3600)) % (24 * 3600) == 0)
//            { // RESET
//                float TG_diff = ground(GR_TG_RESET, i, j) - ground(GR_TG, i, j);
//                float TA_diff = ground(GR_TA_RESET, i, j) - ground(GR_TA, i, j);
//                ground(GR_TG_CORR, i, j) = (TG_diff / (24.0f * 3600.0f)) * dT * 1.2f; //1.2f correction factor
//                ground(GR_TA_CORR, i, j) = (TA_diff / (24.0f * 3600.0f)) * dT * 1.2f;
//            }

//            nextGrid3D(THETA, i, j, 0) = ground(GR_TA, i, j) + gamma * gridSizeK(0) / 100.0f - gridInit(THETA, i, j, 0); //transfer of Ta to THETA
//        }
//    }
//} //STEP 4 


struct FStruct_AirCellColumns_GPU
{
    float U; // u: wind component in the X direction
    float V; // v: wind component in the Y direction
    float W; // w: wind component in the Z direction
    float THETA; // Theta: Potential temperature
    float Pi; // Pi: Exener function
    float RO; // RO: Density (Temp)
    float QV; // qv: Vapor mixing ratio
    float QC; // qc: Condensation mixing ratio
    float QR; // qr: Rain mixing ratio
    float VORT; // Vort: Vorticity
};

//RWTexture1D<float4> MyRWTexture1D;
//RWTexture2D<float4> MyRWTexture2D;
//RWTexture3D<float4> MyRWTexture3D;

RWStructuredBuffer<FStruct_AirCellColumns_GPU> test_outputA; //x5600
//RWStructuredBuffer<FStruct_AirCellColumns_GPU> test_outputB; //x5600
//RWStructuredBuffer<FStruct_AirCellColumns_GPU> test_outputC; //x5600
///////////////////////////////////////////////////////////////////////////
int2 PixelCoord;
int2 MaxResolution;
// RUN SIMULATION
[numthreads(1, 1, 1)]
void simulateStep(uint GroupIndex : SV_GroupIndex, uint3 DispatchThreadId : SV_DispatchThreadID)
{
    //WeatherData.test_outputA[0].U = test_outputA[0].U + 1; //Change this back once fix is in
    test_outputA[0].U = test_outputA[0].U + 1; 
    ShaderPrintSetCursorPos(float2(100, 100));
    ShaderPrintHelloWorld();

    
    PixelCoord = float2(0, 0);
    MaxResolution = float2(1024, 800);


    const float2 PixelPos = PixelCoord;
    if (PixelCoord.x < 0 || PixelCoord.y < 0 || PixelCoord.x >= MaxResolution.x || PixelCoord.y >= MaxResolution.y)
        return;

    ShaderPrintFilter(false);


    const float2 OriginalPos = PixelPos / float2(MaxResolution);
    float2 Pos = OriginalPos;
    
    Pos = ShaderPrintSymbol(Pos, _P_);
    Pos = ShaderPrintSymbol(Pos, _I_);
    Pos = ShaderPrintSymbol(Pos, _X_);
    Pos = ShaderPrintSymbol(Pos, _E_);
    Pos = ShaderPrintSymbol(Pos, _L_);
    Pos = ShaderPrintSymbol(Pos, _SPC_);
    
    
    
    //test_outputB[0].U = test_outputB[0].U+1;
    //test_outputC[0].U = test_outputC[0].U+1;



    // Fundamental equations.
    //simulateSTEP1();
    //simulateSTEP1a();
   // simulateSTEP1b();

    // Microphysics.
    //simulateSTEP2();

    // Move in time.
    //simulateSTEP3();

    // Radiation.
    //simulateSTEP4();

    simulationTime += dT;
}