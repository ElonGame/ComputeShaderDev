#include "/Engine/Private/Common.ush"
#pragma once
#include "WeatherConstantProperties.ush"
#include "WeatherVariableProperties.ush"

//#include "WeatherStep1.ush"
//#include "WeatherStep2.ush"
//#include "WeatherStep3.ush"
//#include "WeatherStep4.ush"

/* Operators to acces the data in a toroidal manner */
int AirRef(RWStructuredBuffer<FStruct_Columns_GPU> var, int arr, int x, int y, int z)
{
    int aI = x; // Toroidal behavior: (x<0)-->(x=gridX-1-x) and (x>gridX-1)-->(x=x-gridX-1)
        
        if (aI < 0)
        aI = gridX + x;
    
        if (aI >= gridX)
        aI = (x % gridX);

    int aJ = y; // Toroidal
    
        if (aJ < 0)
        aJ = gridY + y;
    
        if (aJ >= gridY)
        aJ = (y % gridY);

    int aZ = z;
    int gridK = gridZ;
    
        if (arr == W)
        gridK++;
    
        if ((z < 0 || z >= gridK) && (arr <= 2 || arr == 8))
        { //for values (under z<0, or higher than the gridK) AND they are arr<=2 (u,v,w) or arr==8 (rL)
        return 0.0f;
        }
    
    //We could prevent this by using a texure with x/y clamping?
    aZ = max(0, aZ); //not under
    aZ = min(aZ, gridK - 2); //not over top

    return var[0].Column[arr].Cell[aI + aJ * gridX + aZ * (gridX * gridY)];
}

/* Operators to acces the data in a toroidal manner */
float GroundRef(RWStructuredBuffer<FStruct_Columns_GPU> var,  int arr,  int x,  int y)
{
    int aY = y;  // toroidal behavior

        if (y < 0)aY = gridY + y;
        if (y >= gridY)aY = (y % gridY);

    int aX = x;  // toroidal behavior

        if (x < 0)aX = gridX + x;
        if (x >= gridX)aX = (x % gridX);
    
    return var[0].Column[arr].Cell[aX + aY * gridY];
}


/*//////////////////////////////////////
    FIND AND REPLACE CONVERSIONS:
(gridRslow)\((.*?),(.*?),(.*?),(.*?)\)
(gridInit)\((.*?),(.*?),(.*?),(.*?)\)
AirRef($1, $2, $3, $4, $5)

(ground)\((.*?),(.*?),(.*?)\)
GroundRef($1, $2, $3, $4)

(currGC)\((.*?),(.*?),(.*?),(.*?)\)
(prevGC)\((.*?),(.*?),(.*?),(.*?)\)
(nextGC)\((.*?),(.*?),(.*?),(.*?)\)
AirRef(grid3D[$1].Grid, $2, $3, $4, $5)

powf
pow

logf
log

std::max
max

std::min
min

sqrtf
sqrt

gridSizeK
gridSizeK[0].Cell

*///////////////////////////////////////

///////////////////////////////////////
// SIMULATION STEPS

/* STEP 1 Fundamental Equations */
void simulateSTEP1()
{
        for (int k = 1; k < gridZ - 1; k++)
    {
        for (int j = 0; j < gridY; j++)
        {
            for (int i = 0; i < gridX; i++)
            {

                int km1 = k - 1;
                if (km1 < 0)
                    km1 = 0;

                const float Kx = 500.0f; // diffusion coefficients
                const float Kz = 100.0f;

                AirRef(gridRslow, U, i, j, k) =
          -1.0f / gridSizeI * (pow(0.5f * (AirRef(grid3D[currGC].Grid, U,  i + 1,  j,  k) + AirRef(grid3D[currGC].Grid, U,  i,  j,  k)), 2) - pow(0.5f * (AirRef(grid3D[currGC].Grid, U,  i,  j,  k) + AirRef(grid3D[currGC].Grid, U,  i - 1,  j,  k)), 2)) // -duu/dx

          - 1.0f / gridSizeJ * (
          0.5f * (AirRef(grid3D[currGC].Grid, U,  i,  j + 1,  k) + AirRef(grid3D[currGC].Grid, U,  i,  j,  k)) * 0.5f * (AirRef(grid3D[currGC].Grid, V,  i,  j + 1,  k) + AirRef(grid3D[currGC].Grid, V,  i - 1,  j + 1,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, U,  i,  j,  k) + AirRef(grid3D[currGC].Grid, U,  i,  j - 1,  k)) * 0.5f * (AirRef(grid3D[currGC].Grid, V,  i,  j,  k) + AirRef(grid3D[currGC].Grid, V,  i - 1,  j,  k))) // -duv/dy

          - 1.0f / (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * gridSizeK[0].Cell[k]) * (
          0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * 0.5f * (AirRef(grid3D[currGC].Grid, W,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, W,  i - 1,  j,  k + 1)) * 0.5f * (AirRef(grid3D[currGC].Grid, U,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, U,  i,  j,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * 0.5f * (AirRef(grid3D[currGC].Grid, W,  i,  j,  k) + AirRef(grid3D[currGC].Grid, W,  i - 1,  j,  k)) * 0.5f * (AirRef(grid3D[currGC].Grid, U,  i,  j,  k - 1) + AirRef(grid3D[currGC].Grid, U,  i,  j,  k))) // -dpuw/dz
          - 1.0f / gridSizeI * (cpd * (AirRef(gridInit, THETA,  i,  j,  k) + 0.61f * AirRef(gridInit, QV,  i,  j,  k)) * (AirRef(grid3D[currGC].Grid, Pi,  i,  j,  k) - AirRef(grid3D[currGC].Grid, Pi,  i - 1,  j,  k))) // -cpd*T*dP/dx
          + Kx / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, U,  i + 1,  j,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, U,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, U,  i - 1,  j,  k))
          + Ky / pow(gridSizeJ, 2) * (AirRef(grid3D[prevGC].Grid, U,  i,  j + 1,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, U,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, U,  i,  j - 1,  k))
          + Kz / pow(gridSizeK[0].Cell[k], 2) * ((AirRef(grid3D[prevGC].Grid, U,  i,  j,  k + 1) - AirRef(gridInit, U,  i,  j,  k + 1)) - 2.0f * (AirRef(grid3D[prevGC].Grid, U,  i,  j,  k) - AirRef(gridInit, U,  i,  j,  k)) + (AirRef(grid3D[prevGC].Grid, U,  i,  j,  k - 1) - AirRef(gridInit, U,  i,  j,  k - 1))); // Diffusion (implicit)

                
                AirRef(gridRslow, V,  i,  j,  k) =
          -1.0f / gridSizeI * (
          0.5f * (AirRef(grid3D[currGC].Grid, V,  i + 1,  j,  k) + AirRef(grid3D[currGC].Grid, V,  i,  j,  k)) * 0.5f * (AirRef(grid3D[currGC].Grid, U,  i + 1,  j,  k) + AirRef(grid3D[currGC].Grid, U,  i + 1,  j - 1,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, V,  i,  j,  k) + AirRef(grid3D[currGC].Grid, V,  i - 1,  j,  k)) * 0.5f * (AirRef(grid3D[currGC].Grid, U,  i,  j - 1,  k) + AirRef(grid3D[currGC].Grid, U,  i,  j,  k))) // -dvu/dx 

          - 1.0f / gridSizeJ * (pow(0.5f * (AirRef(grid3D[currGC].Grid, V,  i,  j + 1,  k) + AirRef(grid3D[currGC].Grid, V,  i,  j,  k)), 2) - pow(0.5f * (AirRef(grid3D[currGC].Grid, V,  i,  j,  k) + AirRef(grid3D[currGC].Grid, V,  i,  j - 1,  k)), 2)) // -dvv/dy

          - 1.0f / (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * gridSizeK[0].Cell[k]) * (
          0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * 0.5f * (AirRef(grid3D[currGC].Grid, W,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, W,  i,  j - 1,  k + 1)) * 0.5f * (AirRef(grid3D[currGC].Grid, V,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, V,  i,  j,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * 0.5f * (AirRef(grid3D[currGC].Grid, W,  i,  j,  k) + AirRef(grid3D[currGC].Grid, W,  i,  j - 1,  k)) * 0.5f * (AirRef(grid3D[currGC].Grid, V,  i,  j,  k - 1) + AirRef(grid3D[currGC].Grid, V,  i,  j,  k))) // -dpvw/dz
          - 1.0f / gridSizeJ * (cpd * (AirRef(gridInit, THETA,  i,  j,  k) + 0.61f * AirRef(gridInit, QV,  i,  j,  k)) * (AirRef(grid3D[currGC].Grid, Pi,  i,  j,  k) - AirRef(grid3D[currGC].Grid, Pi,  i,  j - 1,  k))) // -cpd*T*dP/dx
          + Kx / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, V,  i + 1,  j,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, V,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, V,  i - 1,  j,  k))
          + Ky / pow(gridSizeJ, 2) * (AirRef(grid3D[prevGC].Grid, V,  i,  j + 1,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, V,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, V,  i,  j - 1,  k))
          + Kz / pow(gridSizeK[0].Cell[k], 2) * ((AirRef(grid3D[prevGC].Grid, V,  i,  j,  k + 1) - AirRef(gridInit, V,  i,  j,  k + 1)) - 2.0f * (AirRef(grid3D[prevGC].Grid, V,  i,  j,  k) - AirRef(gridInit, V,  i,  j,  k)) + (AirRef(grid3D[prevGC].Grid, V,  i,  j,  k - 1) - AirRef(gridInit, V,  i,  j,  k - 1))); // Diffusion (implicit)

                AirRef(gridRslow, W,  i,  j,  k) =
          -1.0f / gridSizeI * (
          0.5f * (AirRef(grid3D[currGC].Grid, U,  i + 1,  j,  k) + AirRef(grid3D[currGC].Grid, U,  i + 1,  j,  k - 1)) * 0.5f * (AirRef(grid3D[currGC].Grid, W,  i + 1,  j,  k) + AirRef(grid3D[currGC].Grid, W,  i,  j,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, U,  i,  j,  k) + AirRef(grid3D[currGC].Grid, U,  i,  j,  k - 1)) * 0.5f * (AirRef(grid3D[currGC].Grid, W,  i,  j,  k) + AirRef(grid3D[currGC].Grid, W,  i - 1,  j,  k))) // -duw/dx

          - 1.0f / gridSizeJ * (
          0.5f * (AirRef(grid3D[currGC].Grid, V,  i,  j + 1,  k) + AirRef(grid3D[currGC].Grid, V,  i,  j + 1,  k - 1)) * 0.5f * (AirRef(grid3D[currGC].Grid, W,  i,  j + 1,  k) + AirRef(grid3D[currGC].Grid, W,  i,  j,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, V,  i,  j,  k) + AirRef(grid3D[currGC].Grid, V,  i,  j,  k - 1)) * 0.5f * (AirRef(grid3D[currGC].Grid, W,  i,  j,  k) + AirRef(grid3D[currGC].Grid, W,  i,  j - 1,  k))) // -duw/dx

          - 1.0f / (0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * 0.5f * (gridSizeK[0].Cell[k] + gridSizeK[0].Cell[km1])) *
          (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * pow(0.5f * (AirRef(grid3D[currGC].Grid, W,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, W,  i,  j,  k)), 2) - AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1) * pow(0.5f * (AirRef(grid3D[currGC].Grid, W,  i,  j,  k) + AirRef(grid3D[currGC].Grid, W,  i,  j,  k - 1)), 2)) // -dpww/dz
          - 1.0f / (0.5f * (gridSizeK[0].Cell[k] + gridSizeK[0].Cell[km1])) *
          (cpd * 0.5f * (AirRef(gridInit, THETA,  i,  j,  k) + 0.61f * AirRef(gridInit, QV,  i,  j,  k) + AirRef(gridInit, THETA,  i,  j,  k - 1) + 0.61f * AirRef(gridInit, QV,  i,  j,  k - 1))
          * (AirRef(grid3D[currGC].Grid, Pi,  i,  j,  k) - AirRef(grid3D[currGC].Grid, Pi,  i,  j,  k - 1))) // -cpd* T*dP/dz
          + g * 0.5f * (AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k) / AirRef(gridInit, THETA,  i,  j,  k) + AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k - 1) / AirRef(gridInit, THETA,  i,  j,  k - 1)
          + 0.61f * (AirRef(grid3D[currGC].Grid, QV,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QV,  i,  j,  k - 1)) - (AirRef(grid3D[currGC].Grid, QC,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QC,  i,  j,  k - 1) + AirRef(grid3D[currGC].Grid, QR,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QR,  i,  j,  k - 1))) // B=g* T'/T
          + Kx / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, W,  i + 1,  j,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, W,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, W,  i - 1,  j,  k)) // Diffusion (implicit)
          + Ky / pow(gridSizeJ, 2) * (AirRef(grid3D[prevGC].Grid, W,  i,  j + 1,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, W,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, W,  i,  j - 1,  k)) // Diffusion (implicit)
          + Kz / pow(gridSizeK[0].Cell[k], 2) * (AirRef(grid3D[prevGC].Grid, W,  i,  j,  k + 1) - 2.0f * AirRef(grid3D[prevGC].Grid, W,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, W,  i,  j,  k - 1)); // d2w/dx2+d2w/dz2

                AirRef(gridRslow, THETA,  i,  j,  k) =
          -1.0f / gridSizeI * (AirRef(grid3D[currGC].Grid, U,  i + 1,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, THETA,  i + 1,  j,  k) + AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k))
          - AirRef(grid3D[currGC].Grid, U,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k) + AirRef(grid3D[currGC].Grid, THETA,  i - 1,  j,  k))) // -duT/dx

          - 1.0f / gridSizeJ * (AirRef(grid3D[currGC].Grid, V,  i,  j + 1,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, THETA,  i,  j + 1,  k) + AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k))
          - AirRef(grid3D[currGC].Grid, V,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k) + AirRef(grid3D[currGC].Grid, THETA,  i,  j - 1,  k))) // -dvT/dx NN

          - 1.0f / (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * gridSizeK[0].Cell[k]) * (
          0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k + 1) * 0.5f * (AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k) + AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k - 1))) // -dpwT/dz
          - 1.0f / (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * 0.5f * (
          0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k + 1) * (AirRef(gridInit, THETA,  i,  j,  k + 1) - AirRef(gridInit, THETA,  i,  j,  k)) / gridSizeK[0].Cell[k + 1]
          + 0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k) * (AirRef(gridInit, THETA,  i,  j,  k) - AirRef(gridInit, THETA,  i,  j,  k - 1)) / gridSizeK[0].Cell[k]) // -w/p*dpT/dz (mean state)
          + Kx / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, THETA,  i + 1,  j,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, THETA,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, THETA,  i - 1,  j,  k)) // Diffusion (implicit)
          + Ky / pow(gridSizeJ, 2) * (AirRef(grid3D[prevGC].Grid, THETA,  i,  j + 1,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, THETA,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, THETA,  i,  j - 1,  k)) // Diffusion (implicit)
          + Kz / pow(gridSizeK[0].Cell[k], 2) * (AirRef(grid3D[prevGC].Grid, THETA,  i,  j,  k + 1) - 2.0f * AirRef(grid3D[prevGC].Grid, THETA,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, THETA,  i,  j,  k - 1)); // d2T/dx2+d2T/dz2

                AirRef(gridRslow, Pi,  i,  j,  k) =
          -1.0f * (pow(cmax, 2) / (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * cpd * pow(AirRef(gridInit, THETA,  i,  j,  k) + 0.61f * AirRef(gridInit, QV,  i,  j,  k), 2))) * ( // multiplier -cs^2/(cpd* p*T^2)
          +(AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * (AirRef(gridInit, THETA,  i,  j,  k) + 0.61f * AirRef(gridInit, QV,  i,  j,  k)) * (AirRef(grid3D[currGC].Grid, U,  i + 1,  j,  k) - AirRef(grid3D[currGC].Grid, U,  i,  j,  k))) / gridSizeI // pTdu/dx

          + (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * (AirRef(gridInit, THETA,  i,  j,  k) + 0.61f * AirRef(gridInit, QV,  i,  j,  k)) * (AirRef(grid3D[currGC].Grid, V,  i,  j + 1,  k) - AirRef(grid3D[currGC].Grid, V,  i,  j,  k))) / gridSizeJ // pTdv/dx

          + (0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k + 1) * 0.5f * (AirRef(gridInit, THETA,  i,  j,  k + 1) + AirRef(gridInit, THETA,  i,  j,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k) * 0.5f * (AirRef(gridInit, THETA,  i,  j,  k) + AirRef(gridInit, THETA,  i,  j,  k - 1))) / gridSizeK[0].Cell[k] // pTdw/dz
          )
          + Kx / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, Pi,  i + 1,  j,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, Pi,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, Pi,  i - 1,  j,  k)) // Diffusion (implicit)
          + Ky / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, Pi,  i,  j + 1,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, Pi,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, Pi,  i,  j - 1,  k)) // Diffusion (implicit)
          + Kz / pow(gridSizeK[0].Cell[k], 2) * (AirRef(grid3D[prevGC].Grid, Pi,  i,  j,  k + 1) - 2.0f * AirRef(grid3D[prevGC].Grid, Pi,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, Pi,  i,  j,  k - 1)); // d2P/dx2+d2P/dz2

        // Moisture terms
                AirRef(gridRslow, QV,  i,  j,  k) =
          -1.0f / gridSizeI * (AirRef(grid3D[currGC].Grid, U,  i + 1,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QV,  i + 1,  j,  k) + AirRef(grid3D[currGC].Grid, QV,  i,  j,  k))
          - AirRef(grid3D[currGC].Grid, U,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QV,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QV,  i - 1,  j,  k))) // -duqv/dx

          - 1.0f / gridSizeJ * (AirRef(grid3D[currGC].Grid, V,  i,  j + 1,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QV,  i,  j + 1,  k) + AirRef(grid3D[currGC].Grid, QV,  i,  j,  k))
          - AirRef(grid3D[currGC].Grid, V,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QV,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QV,  i,  j - 1,  k))) // -dvqv/dy

          - 1.0f / (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * gridSizeK[0].Cell[k]) * (
          0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k + 1) * 0.5f * (AirRef(grid3D[currGC].Grid, QV,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, QV,  i,  j,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QV,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QV,  i,  j,  k - 1))) // -dpwqv/dz
          - 1.0f / (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * 0.5f * (
          0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k + 1) * (AirRef(gridInit, QV,  i,  j,  k + 1) - AirRef(gridInit, QV,  i,  j,  k)) / gridSizeK[0].Cell[k + 1]
          + 0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k) * (AirRef(gridInit, QV,  i,  j,  k) - AirRef(gridInit, QV,  i,  j,  k - 1)) / gridSizeK[0].Cell[k]) // -w/p*dpqv/dz (mean state)
          + Kx / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, QV,  i + 1,  j,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QV,  i - 1,  j,  k)) // Diffusion (implicit)
          + Ky / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, QV,  i,  j + 1,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QV,  i,  j - 1,  k)) // Diffusion (implicit)
          + Kz / pow(gridSizeK[0].Cell[k], 2) * (AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k + 1) - 2.0f * AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k - 1)); // d2q/dx2+d2q/dz2

                AirRef(gridRslow, QC,  i,  j,  k) =
          -1.0f / gridSizeI * (AirRef(grid3D[currGC].Grid, U,  i + 1,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QC,  i + 1,  j,  k) + AirRef(grid3D[currGC].Grid, QC,  i,  j,  k))
          - AirRef(grid3D[currGC].Grid, U,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QC,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QC,  i - 1,  j,  k))) // -duqv/dx

          - 1.0f / gridSizeJ * (AirRef(grid3D[currGC].Grid, V,  i,  j + 1,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QC,  i,  j + 1,  k) + AirRef(grid3D[currGC].Grid, QC,  i,  j,  k))
          - AirRef(grid3D[currGC].Grid, V,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QC,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QC,  i,  j - 1,  k))) // -duqv/dx

          - 1.0f / (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * gridSizeK[0].Cell[k]) * (
          0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k + 1) * 0.5f * (AirRef(grid3D[currGC].Grid, QC,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, QC,  i,  j,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QC,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QC,  i,  j,  k - 1))) // -dpwqv/dz
          + Kx / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, QC,  i + 1,  j,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QC,  i - 1,  j,  k)) // Diffusion (implicit)
          + Ky / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, QC,  i,  j + 1,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QC,  i,  j - 1,  k)) // Diffusion (implicit)
          + Kz / pow(gridSizeK[0].Cell[k], 2) * (AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k + 1) - 2.0f * AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k - 1)); // d2q/dx2+d2q/dz2

                AirRef(gridRslow, QR,  i,  j,  k) =
          -1.0f / gridSizeI * (AirRef(grid3D[currGC].Grid, U,  i + 1,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QR,  i + 1,  j,  k) + AirRef(grid3D[currGC].Grid, QR,  i,  j,  k))
          - AirRef(grid3D[currGC].Grid, U,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QR,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QR,  i - 1,  j,  k))) // -duqv/dx

          - 1.0f / gridSizeJ * (AirRef(grid3D[currGC].Grid, V,  i,  j + 1,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QR,  i,  j + 1,  k) + AirRef(grid3D[currGC].Grid, QR,  i,  j,  k))
          - AirRef(grid3D[currGC].Grid, V,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QR,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QR,  i,  j - 1,  k))) // -dvqv/dy

          - 1.0f / (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * gridSizeK[0].Cell[k]) * (
          0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k + 1) * 0.5f * (AirRef(grid3D[currGC].Grid, QR,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, QR,  i,  j,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * AirRef(grid3D[currGC].Grid, W,  i,  j,  k) * 0.5f * (AirRef(grid3D[currGC].Grid, QR,  i,  j,  k) + AirRef(grid3D[currGC].Grid, QR,  i,  j,  k - 1))) // -dpwqv/dz
          + Kx / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, QR,  i + 1,  j,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QR,  i - 1,  j,  k)) // Diffusion (implicit)
          + Ky / pow(gridSizeI, 2) * (AirRef(grid3D[prevGC].Grid, QR,  i,  j + 1,  k) - 2.0f * AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QR,  i,  j - 1,  k)) // Diffusion (implicit)
          + Kz / pow(gridSizeK[0].Cell[k], 2) * (AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k + 1) - 2.0f * AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k - 1)); // d2q/dx2+d2q/dz2

                AirRef(gridRslow, RO,  i,  j,  k) = 0.0f;
            }
        }
    }
} //

/* STEP2: Kelsner Microphysics */
void simulateSTEP2()
{

    for (int k = 1; k < gridZ - 1; k++)
    {
        for (int j = 0; j < gridY; j++)
        {
            for (int i = 0; i < gridX; i++)
            {

        // Kessler microphysics.
        // A = max[ k1 * (qc-qc0) , 0 ] : autoconverstion qc -> qr
        // B = k2 * qc * qr^7/8	: accretion qc -> qr
        // C: condensation ; qv <-> qv
        // E: evaporation ; qr -> qv
        // All values from t-1 step
        // Order of calculation matters here

                float A_conv = 0.0;
                if (AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k) > 0.001)
                    A_conv = max(0.0f, 0.001 * (AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k) - 0.001)); // conversion cloud -> rain

                float B_acc = max(0.0f, AirRef(gridInit, RO,  i,  j,  k) * 2.2f * AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k) * pow(AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k), 0.875f)); // accretion cloud -> rain

                A_conv *= rainProbability;
                B_acc *= rainProbability;

        // Saturation adjustment (Soong & Ogura)
                float pmean = pow(AirRef(gridInit, Pi,  i,  j,  k), cpd / Rd) * p_0; // Mean pressure
                float qvs = (380.0f / pmean) * exp(7.5f * log(10.0f) *
          ((AirRef(grid3D[prevGC].Grid, THETA,  i,  j,  k) + AirRef(gridInit, THETA,  i,  j,  k)) * ((AirRef(grid3D[prevGC].Grid, Pi,  i,  j,  k) + AirRef(gridInit, Pi,  i,  j,  k))) - 273.0f) /
          ((AirRef(grid3D[prevGC].Grid, THETA,  i,  j,  k) + AirRef(gridInit, THETA,  i,  j,  k)) * ((AirRef(grid3D[prevGC].Grid, Pi,  i,  j,  k) + AirRef(gridInit, Pi,  i,  j,  k))) - 36.0f)); // Saturation mixing ratio
                AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k) = max(AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k), -1.0f * AirRef(gridInit, QV,  i,  j,  k)); // remove negative values
                float rsub = qvs * (7.5f * log(10.0f) * (273.0f - 36.0f) * Llv / cpd) /
          pow(AirRef(gridInit, Pi,  i,  j,  k) * (AirRef(grid3D[prevGC].Grid, THETA,  i,  j,  k) + AirRef(gridInit, THETA,  i,  j,  k)), 2);

                float Cond = min(AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k) + AirRef(gridInit, QV,  i,  j,  k),
          max(0.0f, ((AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k) + AirRef(gridInit, QV,  i,  j,  k)) - qvs) / (1.0f + rsub))); // Condensation (qv -> qc)

                float Cvent = 1.6f + 124.9f * pow(AirRef(gridInit, RO,  i,  j,  k) * AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k), 0.2046f); // ventillation factor
                float Evap = (min(AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k), max(-1.0f * Cond - AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k), 0.0f)), // 3 options
                dT * Cvent * pow(AirRef(gridInit, RO,  i,  j,  k) * AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k), 0.525f) / (5.4e5 + 2.55e8 / (pmean * qvs))
          * max(qvs - AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k), 0.0f) / (AirRef(gridInit, RO,  i,  j,  k) * qvs));
                Cond = max(Cond, -1.0f * AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k));

                AirRef(gridRslow, QV,  i,  j,  k) = AirRef(gridRslow, QV,  i,  j,  k) - Cond + Evap; // Net mass conversion

                AirRef(gridRslow, QC,  i,  j,  k) = AirRef(gridRslow, QC,  i,  j,  k) + Cond - A_conv - B_acc; // Net mass conversion

                float vterm0 = 36.34f * sqrt(AirRef(gridInit, RO,  i,  j,  0) / AirRef(gridInit, RO,  i,  j,  k)) * pow(max(AirRef(gridInit, RO,  i,  j,  k) * AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k), 0.0f), 0.1364f);
                float vterm1 = 36.34f * sqrt(AirRef(gridInit, RO,  i,  j,  0) / AirRef(gridInit, RO,  i,  j,  k + 1)) * pow(max(AirRef(gridInit, RO,  i,  j,  k + 1) * AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k + 1), 0.0f), 0.1364f); // vT terminal velocity
        // note, it's possible that vT > CFL.

                AirRef(gridRslow, QR,  i,  j,  k) = AirRef(gridRslow, QR,  i,  j,  k) + A_conv + B_acc - Evap // Net mass change
          + 1.0f / (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) * gridSizeK[0].Cell[k]) * (
          0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k + 1) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k)) * vterm1 * 0.5f * (AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k + 1) + AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k))
          - 0.5f * (AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[currGC].Grid, RO,  i,  j,  k - 1)) * vterm0 * 0.5f * (AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k - 1))); // Falling rain

                AirRef(gridRslow, THETA,  i,  j,  k) = AirRef(gridRslow, THETA,  i,  j,  k) + Llv / (cpd * AirRef(gridInit, Pi,  i,  j,  k)) * (Cond - Evap); // latent heating Lv/(cpd * P) * (C-E);
            }
        }
    }
}

/* STEP3: Move forward in time */
void simulateSTEP3()
{

    for (int k = 1; k < gridZ - 1; k++)
    {
        for (int j = 0; j < gridY; j++)
        {
            for (int i = 0; i < gridX; i++)
            {

                if (simulationTime == 0.0f)
                { // 1st step: forward in time
          //	printf("first Iteration\n");
                    AirRef(grid3D[nextGC].Grid, U,  i,  j,  k) = AirRef(grid3D[currGC].Grid, U,  i,  j,  k) + dT * AirRef(gridRslow, U,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, V,  i,  j,  k) = AirRef(grid3D[currGC].Grid, V,  i,  j,  k) + dT * AirRef(gridRslow, V,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, W,  i,  j,  k) = AirRef(grid3D[currGC].Grid, W,  i,  j,  k) + dT * AirRef(gridRslow, W,  i,  j,  k);
                    if ((k < 2))
                        AirRef(grid3D[nextGC].Grid, W,  i,  j,  k) = 0.0f; // top & bottom BCs //|| (k==zEnd)
                    AirRef(grid3D[nextGC].Grid, Pi,  i,  j,  k) = AirRef(grid3D[currGC].Grid, Pi,  i,  j,  k) + dT * AirRef(gridRslow, Pi,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, THETA,  i,  j,  k) = AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k) + dT * AirRef(gridRslow, THETA,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, QV,  i,  j,  k) = AirRef(grid3D[currGC].Grid, QV,  i,  j,  k) + dT * AirRef(gridRslow, QV,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, QC,  i,  j,  k) = AirRef(grid3D[currGC].Grid, QC,  i,  j,  k) + dT * AirRef(gridRslow, QC,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, QR,  i,  j,  k) = AirRef(grid3D[currGC].Grid, QR,  i,  j,  k) + dT * AirRef(gridRslow, QR,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, RO,  i,  j,  k) = AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + dT * AirRef(gridRslow, RO,  i,  j,  k);

                }
                else
                { // subsequent steps: leapfrog

          //	printf("No first Iteration\n");
                    AirRef(grid3D[nextGC].Grid, U,  i,  j,  k) = AirRef(grid3D[prevGC].Grid, U,  i,  j,  k) + 2.0f * dT * AirRef(gridRslow, U,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, V,  i,  j,  k) = AirRef(grid3D[prevGC].Grid, V,  i,  j,  k) + 2.0f * dT * AirRef(gridRslow, V,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, W,  i,  j,  k) = AirRef(grid3D[prevGC].Grid, W,  i,  j,  k) + 2.0f * dT * AirRef(gridRslow, W,  i,  j,  k);
                    if ((k < 2))
                        AirRef(grid3D[nextGC].Grid, W,  i,  j,  k) = 0.0f; // top & bottom BCs // || (k==zEnd)
                    AirRef(grid3D[nextGC].Grid, Pi,  i,  j,  k) = AirRef(grid3D[prevGC].Grid, Pi,  i,  j,  k) + 2.0f * dT * AirRef(gridRslow, Pi,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, THETA,  i,  j,  k) = AirRef(grid3D[prevGC].Grid, THETA,  i,  j,  k) + 2.0f * dT * AirRef(gridRslow, THETA,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, QV,  i,  j,  k) = AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k) + 2.0f * dT * AirRef(gridRslow, QV,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, QC,  i,  j,  k) = AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k) + 2.0f * dT * AirRef(gridRslow, QC,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, QR,  i,  j,  k) = AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k) + 2.0f * dT * AirRef(gridRslow, QR,  i,  j,  k);
                    AirRef(grid3D[nextGC].Grid, RO,  i,  j,  k) = AirRef(grid3D[prevGC].Grid, RO,  i,  j,  k) + 2.0f * dT * AirRef(gridRslow, RO,  i,  j,  k);

          // Roberts-Asselin filter
                    AirRef(grid3D[currGC].Grid, U,  i,  j,  k) = AirRef(grid3D[currGC].Grid, U,  i,  j,  k) + 0.1f * (AirRef(grid3D[nextGC].Grid, U,  i,  j,  k) - 2.0f * AirRef(grid3D[currGC].Grid, U,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, U,  i,  j,  k));
                    AirRef(grid3D[currGC].Grid, V,  i,  j,  k) = AirRef(grid3D[currGC].Grid, V,  i,  j,  k) + 0.1f * (AirRef(grid3D[nextGC].Grid, V,  i,  j,  k) - 2.0f * AirRef(grid3D[currGC].Grid, V,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, V,  i,  j,  k));
                    AirRef(grid3D[currGC].Grid, W,  i,  j,  k) = AirRef(grid3D[currGC].Grid, W,  i,  j,  k) + 0.1f * (AirRef(grid3D[nextGC].Grid, W,  i,  j,  k) - 2.0f * AirRef(grid3D[currGC].Grid, W,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, W,  i,  j,  k));
                    AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k) = AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k) + 0.1f * (AirRef(grid3D[nextGC].Grid, THETA,  i,  j,  k) - 2.0f * AirRef(grid3D[currGC].Grid, THETA,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, THETA,  i,  j,  k));
                    AirRef(grid3D[currGC].Grid, Pi,  i,  j,  k) = AirRef(grid3D[currGC].Grid, Pi,  i,  j,  k) + 0.1f * (AirRef(grid3D[nextGC].Grid, Pi,  i,  j,  k) - 2.0f * AirRef(grid3D[currGC].Grid, Pi,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, Pi,  i,  j,  k));
                    AirRef(grid3D[currGC].Grid, QV,  i,  j,  k) = AirRef(grid3D[currGC].Grid, QV,  i,  j,  k) + 0.1f * (AirRef(grid3D[nextGC].Grid, QV,  i,  j,  k) - 2.0f * AirRef(grid3D[currGC].Grid, QV,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QV,  i,  j,  k));
                    AirRef(grid3D[currGC].Grid, QC,  i,  j,  k) = AirRef(grid3D[currGC].Grid, QC,  i,  j,  k) + 0.1f * (AirRef(grid3D[nextGC].Grid, QC,  i,  j,  k) - 2.0f * AirRef(grid3D[currGC].Grid, QC,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QC,  i,  j,  k));
                    AirRef(grid3D[currGC].Grid, QR,  i,  j,  k) = AirRef(grid3D[currGC].Grid, QR,  i,  j,  k) + 0.1f * (AirRef(grid3D[nextGC].Grid, QR,  i,  j,  k) - 2.0f * AirRef(grid3D[currGC].Grid, QR,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, QR,  i,  j,  k));
                    AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) = AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + 0.1f * (AirRef(grid3D[nextGC].Grid, RO,  i,  j,  k) - 2.0f * AirRef(grid3D[currGC].Grid, RO,  i,  j,  k) + AirRef(grid3D[prevGC].Grid, RO,  i,  j,  k));
                }
            }
        }
    }
} // STEP 3

/* STEP4: Radiation model */
void simulateSTEP4()
{

    for (int j = 0; j < gridY; j++)
    {
        for (int i = 0; i < gridX; i++)
        {

            const float T_M = 29.0f + 273.15f; // Invariable slab temperature //INIT 10.0f 32.0f
            const float dur = 3600.0f * 24.0f; // * 5.0f;//24h
            const float S_const = -1.127f; //Solar constant km/s

      ////////////////////////////////////////
      // INIT VALUES
            if (simulationTime == 0.0f)
            { // 1st step: forward in time 
                AirRef(grid3D[currGC].Grid, THETA,  i,  j,  0) = 0;

                GroundRef(ground, GR_TG,  i,  j) = 23.5f + 273.15f;
                GroundRef(ground, GR_TA,  i,  j) = AirRef(gridInit,  THETA,  i,  j,  0);

                GroundRef(ground, GR_TG_RESET,  i,  j) = FLT_MAX; // INF

                GroundRef(ground, GR_TG_CORR,  i,  j) = 0.0f;
                GroundRef(ground, GR_TA_CORR,  i,  j) = 0.0f;

                GroundRef(ground, GR_CLOUD_COVER,  i,  j) = 0.0f;
            }

      ////////////////////////////////////////
      // CLOUD COVERAGE

            if ((int(simulationTime / dT) % (60 * 5)) == 0)
            { // each 300 steps
                float cloudTotal = 0.0f;
                for (int z = (0.33f * gridZ); z < (0.83f * gridZ); z++)
                {
                    float density = AirRef(grid3D[nextGC].Grid, QC,  i,  j,  z);
                    if (density == 0.0f)
                        continue;
                    if (density > 2e-3f)
                    {
                        density = 0.99f;
                    }
                    else
                    {
                        if (density < 1e-3f)
                        {
                            density = 0.0f;
                        }
                        else
                        {
                            density = -1520000.0f * (density * density) + 5360.00f * (density) - 3.74f;
                        }
                    }
                    cloudTotal += density * 0.1f; //0.05f so it has soft borders
                    if (cloudTotal >= 1.0f)
                    {
                        break; // not necessary to check more
                    }
                }
                GroundRef(ground, GR_CLOUD_COVER,  i,  j) = min(cloudTotal,  1.0f);
            }


      ////////////////////////////////////////
      // UTC
            float t_UTC = initTimeUTC_hours + (simulationTime / 3600.0f); //day overflow
            int advancedDays = int(t_UTC / (24.0f)); //full days
            float dayInYearUTC = initDayInYearUTC + advancedDays;
            while (dayInYearUTC > 365)
                dayInYearUTC -= 365;
            t_UTC -= advancedDays * 24.0f;

      ////////////////////////////////////////
      // LOCAL
            float t_Local = t_UTC + timeZone;
            if (t_Local < 0.0f)
                t_Local += 24.0f;
            if (t_Local > 24.0f)
                t_Local -= 24.0f;


            float lat = latitudeRad;
            float longi = -longitudeRad; //note NEGATE (West)

            float delta = 0.409f * cos((2.0f * M_PI) * (dayInYearUTC - 173.0f) / (365.25f)); //d_s: solarDeclineAngle
            float sinPSI = sin(lat) * sin(delta) - cos(lat) * cos(delta) * cos(((M_PI * t_UTC) / 12.0f) - longi);

            float gamma = 0.0000010717f * pow(t_Local, 5.0f) + 0.0000818369f * pow(t_Local, 4.0f) - 0.0060500842f * pow(t_Local, 3.0f) + 0.0772306397f * pow(t_Local, 2.0f) + 0.1444444444f * t_Local - 1.8441558442f;

      ////////////////////////////////////////
      // RADITATION

            float alb = GroundRef(ground, GR_ALBEDO,  i,  j);
            float c_g_a = GroundRef(ground, GR_CGA,  i,  j);

            float sig_l = GroundRef(ground, GR_CLOUD_COVER,  i,  j);
            float sig_m = GroundRef(ground, GR_CLOUD_COVER,  i,  j);
            const float sig_h = 0.1f;

            float I = 0.08f * (1.0f - 0.1f * sig_h - 0.3f * sig_m - 0.6f * sig_l);

            float Tk = (0.6f + 0.2f * sinPSI) * (1.0f - 0.4f * sig_h) * (1.0f - 0.7f * sig_m) * (1.0f - 0.4f * sig_l); //trans
            float Q_net = (1.0f - alb) * S_const * Tk * sinPSI + I;
            if (sinPSI < 0)
                Q_net = I;
            float a_fr;
            if (GroundRef(ground, GR_TG,  i,  j) > GroundRef(ground, GR_TA,   i,  j))
            {
        //DAY
                a_fr = 3e-4f;
            }
            else
            {
        //NIGHT
                a_fr = 1.1e-4f;
            }

            float T_G_t = ((-Q_net / c_g_a) + (2.0f * M_PI / dur * (T_M - GroundRef(ground, GR_TG,  i,  j))) - (a_fr * (GroundRef(ground, GR_TG,   i,  j) - GroundRef(ground, GR_TA,   i,  j))));
            float Q_g = -1.0f * ((c_g_a * T_G_t) + (2.0f * M_PI * c_g_a / dur * (GroundRef(ground, GR_TG,  i,  j) - T_M))); //Units are fomd
            float Q_h = (-Q_net + Q_g) / GroundRef(ground, GR_BETA_INV,  i,  j);

            GroundRef(ground, GR_TG,  i,  j) += (dT * T_G_t) + GroundRef(ground, GR_TG_CORR,   i,  j); // NEW TG
            GroundRef(ground, GR_TA,  i,  j) += (dT * Q_h * 1.0e-3f) + GroundRef(ground, GR_TA_CORR,   i,  j); // Introduced this new time parameterization //NEW TA

      ///////////////////////////////////
      // STEP 0: Save AirRef value after 2 hours of simulation
            if ((GroundRef(ground, GR_TG_RESET,  i,  j) == FLT_MAX) && (simulationTime >= 3600.0f * 2.0f))
            { // put first FLT_MAX to avoid to comparisons
                GroundRef(ground, GR_TG_RESET,  i,  j) = GroundRef(ground, GR_TG,   i,  j);
                GroundRef(ground, GR_TA_RESET,  i,  j) = GroundRef(ground, GR_TA,   i,  j);
                if (i == 0 && j == 0)
                {
                    printf("** Save AirRef: %f (%.2f)\n", simulationTime, simulationTime / 3600.0f);
                }
            }

      ///////////////////////////////////
      // STEP1: Update Correction after Each 24hours (+2h)
            if ((simulationTime >= 3600.0f * (2.0f + 24.0f)) && ((int(simulationTime) - 2 * 3600)) % (24 * 3600) == 0)
            { // RESET
                if (i == 0)
                {
                    printf("** Reset: %f (%f)\n", simulationTime, simulationTime / 3600.0f);
                }
                float TG_diff = GroundRef(ground, GR_TG_RESET,  i,  j) - GroundRef(ground, GR_TG,   i,  j);
                float TA_diff = GroundRef(ground, GR_TA_RESET,  i,  j) - GroundRef(ground, GR_TA,   i,  j);
                GroundRef(ground, GR_TG_CORR,  i,  j) = (TG_diff / (24.0f * 3600.0f)) * dT * 1.2f; //1.2f correction factor
                GroundRef(ground, GR_TA_CORR,  i,  j) = (TA_diff / (24.0f * 3600.0f)) * dT * 1.2f;
            }

            AirRef(grid3D[nextGC].Grid, THETA,  i,  j,  0) = GroundRef(ground, GR_TA,  i,  j) + gamma * gridSizeK[0].Cell[0] / 100.0f - AirRef(gridInit,  THETA,  i,  j,  0); //transfer of Ta to THETA
        }
    }
} //STEP 4


///////////////////////////////////////////////////////////////////////////
// RUN SIMULATION
[numthreads(1, 1, 1)]
void simulateStep(uint3 DTid : SV_DispatchThreadID)
{

  // Run sumulation.
    const bool check = true;
    for (int nS = 0; nS < numSteps; nS++)
    {
        int nextInd = (currInd + 1) % 3; //3 number of time array
        int prevInd = (currInd - 1);
        if (prevInd < 0)
            prevInd = 2; // Set the last step.


    // Fundamental equations.
        simulateSTEP1();

    // Microphysics.
        simulateSTEP2();

    // Move in time.
        simulateSTEP3();

    // Radiation.
        simulateSTEP4();

        currInd = (currInd + 1) % 3; // 3 number of time array

        simulationTime += dT;
    }
}